首先对sdk做了一次二次封装，创建一个单例类`**PenCtrlSdkManager**`**实现对智能笔的使用**
# 初始化SDK
初始化sdk需要做的操作有

1. 初始化NQPen
2. 初始化页面大小
3. 设置屏幕常亮
4. 设置远程解析

此方法提供给需要初始化智能笔设备时调用
```groovy
public void init(@NonNull Context context, NQPenSDK.CONN_TYPE type) {
    mContext = context;
    mConnType = type;
    //初始化
    NQPenSDK.getInstance().init(context, type, initListener);
    //初始化页面尺寸
    setDefaultPageSize();
    //获取电源锁，保持CPU运转，保持屏幕常亮(亮度低)
    PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, PenCtrlSdkManager.class.getName());

    if(null!=mWakeLock){

        mWakeLock.acquire();
    }

    //设置远程解析
    NQPenSDK.getInstance().setRemoteParse(false);
}
```
# 释放SDK
释放sdk方法主要做的操作：

1. 设置当前设备为空
2. 使用sdk资源
3. 释放屏幕常亮锁定

此方法一般在退出应用或者断开智能笔连接时调用，以及再更换连接设备时要先调用释放sdk方法，保证先释放旧连接，再尝试新连接
```groovy
/**
 * 使用sdk资源
 * 断开智能笔时调用
 */
public void release() {
    setCurNQDev(null);
    //释放SDK资源
    NQPenSDK.getInstance().release();
    //释放电源锁
    if(null!=mWakeLock){

        mWakeLock.release();
    }
}
```
# 当前设备
当前设备的get和set方法，再其他界面可以通过此方法快速获得当前设备的实例
```groovy
/**
 *
 * @return 当前连接的设备
 */
public NQDeviceBase getCurNQDev() {
    return mCurNQDev;
}

public void setCurNQDev(NQDeviceBase curNQDev) {
    this.mCurNQDev = curNQDev;
}
```
# 两个重要的回调
设置回调方法是为了能够主动监听得到设备的状态信息，两个回调分别是：

1. sdk初始化回调
2. 扫描回调
## sdk初始化回调
此回调是为了能监听在初始化sdk是是否成功，在初始化sdk的`**init**`方法时会设置sdk初始化回调
```groovy
//此行代码来自init()方法
//初始化
NQPenSDK.getInstance().init(context, type, initListener);
```
在sdk初始化成功之后才会设置连接回调，监听在连接设备时的连接成功与否
```groovy
/**
 * SDK初始化回调
 */
InitListener initListener = new InitListener() {
    @Override
    public void success(NQPenSDK.CONN_TYPE conn_type) {
        LogUtils.d("init sdk success...");
        //设置扫描连接监听
        NQPenSDK.getInstance().setPenConnectListener(connectListener);
        //查找设备
        startScanDevice();
    }

    @Override
    public void failure(int error, String message) {
        LogUtils.e("init sdk failure error="+error+", message="+message);
    }
};
```
## 扫描回调
扫描回调监听扫描设备时的状态信息，连接状态如果为已连接则发送广播
```groovy
/**
 * 扫描连接监听
 */
PenConnectListener connectListener = new PenConnectListener() {
    /**
     * 连接状态
     * @param state
     */
    @Override
    public void onConnectState(int state) {
//            LogUtils.d("onConnectState state="+state);
        mConnState = state;
        if (null != mConnectListener) {
            mConnectListener.onConnectState(state);
        }

        //当前状态是已连接
        if(state==ConnectState.CONN_STATE_CONNECTED){
            mContext.sendBroadcast(new Intent(Const.Broadcast.ACTION_CONNECTED));
        }
    }


    /**
     * 扫描异常
     * @param error
     * @param message
     */
    @Override
    public void onReceiveException(int error, String message) {
        LogUtils.e("receiveException error=" + error + ", message=" + message);

        Intent intent = new Intent(Const.Broadcast.ACTION_FIND_ERROR);
        intent.putExtra("error", error);
        intent.putExtra("message", message);
        if (null != mContext) {
            mContext.sendBroadcast(intent);
        }

        if(null!=mScanListener){
            mScanListener.onReceiveException(error, message);
        }
        if(null!=mConnectListener){
            mConnectListener.onReceiveException(error, message);
        }
    }

};
```
# Activity使用
在MainActivity中负责初始化SDK和连接设备，具体操作如下：

1. 调用PenCtrlSdkManager的init方法初始化sdk
2. 设置智能笔的各类监听
3. 开始搜索设备

在MainActivity的initView中调用intiPenSDK();方法，其中分别实现了以上三个动作。之所以在启动界面时就初始化sdk并扫描设备是为了优化用户体验，减少用户的等待时间。
```groovy
/**
 * 初始化笔SDK
 */
private void intiPenSDK() {
    //sdk管理单例到初始化，PenCtrlSdkManager是智能笔SDK管理单例，对sdk进行二次封装
    PenCtrlSdkManager.getInstance().init(getApplication(), NQPenSDK.CONN_TYPE.BLE);
    //添加监听器
    setPenListener();
    //开始搜索
    PenCtrlSdkManager.getInstance().startScanDevice();
}
```
## 设置扫描监听器
可以根据功能的需要设置对应的回调监听，当然必须的扫描和连接功能回调是必须要实现的。因为连接监听是初始化sdk，而扫描监听是主动扫描附近的可连接智能笔设备。
```groovy
/**
 * 设置各类事件监听
 */
private void setPenListener() {
    //设置扫描回调
    PenCtrlSdkManager.getInstance().setScanListener(mScanListener);
    //设置实时书写点接收监听
//        PenCtrlSdkManager.getInstance().setDotListener(penDotListener);
    //监听离线同步数据
//        PenCtrlSdkManager.getInstance().setPenOfflineDataListener(offlineDataListener);
    //设置连接监听
    PenCtrlSdkManager.getInstance().setConnectListener(connectListener);
    //设置笔信息监听
//        PenCtrlSdkManager.getInstance().setPenMsgListener(penMsgListener);
}
```
着重看一下扫描回调监听的具体实现：在其中主要有四个方法分别是：

1. onScanStart扫描开始：开始时需要清除设备列表
2. onScanStop扫描停止：扫描停止时回调
3. onReceiveException扫描异常：扫描设备时出现异常才回调
4. onScanResult扫描结果：扫描结果有一个参数那就是扫描到的设备，我们可以将它添加到成员列表`**mDeviceLists**`中
```groovy
/**
 * 扫描监听
 */
ScanListener mScanListener = new ScanListener() {
    @Override
    public void onScanStart() {

        mDeviceLists.clear();
        Log.i(TAG, "onScanStart: 开始");

    }

    @Override
    public void onScanStop() {

        Log.i(TAG, "onScanStop: 停止");
    }

    @Override
    public void onReceiveException(int error, String message) {
        LogUtils.e("error="+error+", message="+message);
    }

    @Override
    public void onScanResult(final NQDeviceBase device) {

        Log.i(TAG, "onScanResult: device"+device.exInfo);
        //搜索到一个设备
        addDevice(device);
    }
};
```
## 添加设备
具体来看一下`**addDevice**`**的实现，它负责将新扫描得到的结果添加到成员列表**`**mDeviceLists**`**中。在添加之前过滤避免重复添加同一只笔的实例**
```groovy
private void addDevice(NQDeviceBase device) {
    //避免重复添加.

   NQBtDevice btDevice=(NQBtDevice) device;
    for (NQDeviceBase d:mDeviceLists) {
        NQBtDevice dDevice=(NQBtDevice)d;
        Log.i(TAG, "addDevice: "+dDevice.mac+" "+Thread.currentThread());
        if(dDevice.mac.equals(btDevice.mac)){
            return;
        }
    }
    mDeviceLists.add(device);
    if(dialog!=null){
        dialog.addDeviceData(device);
    }
}
```
## 连接设备
`**Select()**`**和**`**freshDevice()**`方法是dialog中的回调方法（关于dialog的具体实现可以查看文档[连接蓝牙自定义dialog](https://www.yuque.com/starryluli/tg8bvk/xn6dgz4lx6bursmp)），负责监听用户的选择连接和刷新列表操作。在选择连接时，负责检验设备的mac地址最终调用`PenCtrlSdkManager`中的`connect`方法。至此设备来连接成功。
```groovy
PenCtrlSdkManager.getInstance().connect(device);
```
```groovy
private void showConnectDialog() {
    Bundle bundle=new Bundle();
    bundle.putParcelableArrayList(ListFragmentDialog.KEY_CONTENT_LIST,mDeviceLists);
    if (dialog == null) {
        dialog = new ListFragmentDialog();
        dialog.setArguments(bundle);
        dialog.show(getSupportFragmentManager(),"");
        dialog.setOnSelectListener(new ListFragmentDialog.SelectListener() {
            @Override
            public void Select(NQDeviceBase deviceBase) {
                NQBtDevice device=(NQBtDevice) deviceBase;
                ToastUtils.showLong(device.name);
                if(!TextUtils.isEmpty(device.mac)){
                    PenCtrlSdkManager.getInstance().connect(device);
                }
            }
            @Override
            public void freshDevice() {
                searchDevices();
            }
        });
    }else{
        dialog.setArguments(bundle);
        dialog.show(getSupportFragmentManager(), "");
    }
}
```
