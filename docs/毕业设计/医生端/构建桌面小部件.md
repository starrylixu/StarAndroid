[https://juejin.cn/post/7296031991320870912?searchId=20231125170129FFB34EC3C3EC3DAC0BAE#heading-1](https://juejin.cn/post/7296031991320870912?searchId=20231125170129FFB34EC3C3EC3DAC0BAE#heading-1)
[https://developer.android.google.cn/guide/topics/appwidgets?hl=zh-cn#java](https://developer.android.google.cn/guide/topics/appwidgets?hl=zh-cn#java)
# 什么是桌面小部件
能够在桌面展示一个特定的View，它的实现原理是RemoteViews，这是一种能够跨进程通信的View
# 如何使用小部件

- 第一步，创建声明小部件信息的XML，告诉系统这个小部件长怎么样和一些配置信息。
- 第二步，创建BroadcastReceiver，接收小部件的各种事件（添加，删除，更新等）。
- 第三步，创建View，将创建的View更新在桌面上。
## 首先需要声明基本信息
在项目的`res/xml/ `目录下面创建一`个app_widget_info.xml`，使用 `<appwidget-provider>` 标签，类似写布局一样，将小部件的信息声明一下，告诉系统这个小部件长怎么样和一些配置信息。
```java
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_provider"
    android:minWidth="110dp"
    android:minHeight="110dp"
    android:previewImage="@drawable/ic_logo"
    android:updatePeriodMillis="86400000" />

```
其中的属性介绍一下：

- initialLayout：是初始化的布局
- updatePeriodMillis：是小部件定时更新的时间间隔，单位为毫秒，最低要是30min，也就是86400000毫秒，因为涉及跨进程通信，更新太频繁很消耗性能。
- minWidth和minHeight：很好理解就是小部件的宽和高
- previewImage：使用图片作为预览，在添加界面展示。
## 创建BroadcastReceiver
系统会将小部件的更新和生命周期以发送广播的方式通知到我们，所以我们需要创建一个BroadcastReceiver来接收这些事件。
AppWidgetProvider是Android系统提供的专门用于小部件通知的BroadcastReceiver，我们可以继承它去实现自定义的通知。
```java
//系统源码
public class AppWidgetProvider extends BroadcastReceiver {
    //构造方法
    public AppWidgetProvider() {
        
    }

    public void onReceive(Context context, Intent intent) {
    }

    //小部件创建、定时更新触发等时机会调用。
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        
    }

    public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager, int appWidgetId, Bundle newOptions) {
       
    }

    //小部件被删除的时候会被调用。
    public void onDeleted(Context context, int[] appWidgetIds) {
      
    }

    //小部件被第一次创建的时候会调用，可能会创建多个，只有第一个的时候会调用。
    public void onEnabled(Context context) {
       
    }

    //最后一个小部件被删除的时候调用，与onDeleted的区别是，onDeleted每次删除都会调用。
    public void onDisabled(Context context) {
       
    }

    public void onRestored(Context context, int[] oldWidgetIds, int[] newWidgetIds) {
       
    }
}

```
可以看到有诸多的空方法，我们可以根据需要的逻辑选择去实现
例如我们实现一个简单的小部件AppWidgetProvider，并且创建一个点击事件，这样用户就能通过小部件进入App的主界面
```java
public class MedicalAppWidgetProvider extends AppWidgetProvider {

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        super.onUpdate(context, appWidgetManager, appWidgetIds);

        Intent intent=new Intent(context, MainActivity.class);
        PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,0);

        RemoteViews views=new RemoteViews(context.getPackageName(), R.layout.widget_provider);
        views.setOnClickPendingIntent(R.id.ll_remote,pendingIntent);
        appWidgetManager.updateAppWidget(appWidgetIds,views);
    }
}

```
以下是我的布局`R.layout.widget_provider`的实现，就是一个简单的TextView
```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:id="@+id/ll_remote"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="桌面小部件" />
</LinearLayout>
```
## 在manifest中声明
```java
<receiver android:name="com.eningqu.aipen.ui.view.MedicalAppWidgetProvider"
    android:exported="false"
    android:label="智能电子笔">
    <intent-filter>
        <!-- 接收系统事件，例如生命周期等-->
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/app_widget_info"/>
</receiver>
```
