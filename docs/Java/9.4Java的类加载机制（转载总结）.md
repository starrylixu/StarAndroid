类加载思维导图看这篇
[Carson带你学JVM：类加载的全过程解析](https://www.jianshu.com/p/3ca14ec823d7)
类加载机制详细文字介绍看这篇
[Java类加载机制（全套） - 掘金](https://juejin.cn/post/6844903564804882445#heading-1)

1. 什么是类加载机制（本质）
2. 类加载的步骤
# 什么是类的加载
将**描述类的数据** 从**Class文件**加载到**内存 **& 对数据进行校验、转换解析 和 初始化，最终形成可被虚拟机直接使用的Java使用类型
# 类的生命周期（加载过程）
![](https://cdn.nlark.com/yuque/0/2023/jpeg/32682386/1682065024995-656fb408-7731-4e26-b393-2532348fe82c.jpeg#averageHue=%23b8bab1&clientId=u4b5566c7-a8ff-4&from=paste&id=u64f64ed8&originHeight=217&originWidth=693&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u03b7e2bf-874b-412c-9c2a-cf30ea307b4&title=)
类的生命周期包括  加载、连接、初始化、使用和卸载：

1. 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
2. 连接，连接又包含三块内容：验证、准备、解析。
   1. 验证，文件格式、元数据、字节码、符号引用验证；
   2. 准备，为类的静态变量分配内存，并将其初始化为默认值；
   3. 解析，把类中的符号引用转换为直接引用
3. 初始化，为类的静态变量赋予正确的初始值
4. 使用，new出对象程序中使用
5. 卸载，执行垃圾回收
## 加载
类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的**方法区**内，然后在**堆区**创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是**位于堆区中的Class对象**，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
加载.class文件的方式有:

1. 从本地系统中直接加载
2. 通过网络下载.class文件 
3. 从zip，jar等归档文件中加载.class文件
4. 从专有数据库中提取.class文件 
5. 将Java源文件动态编译为.class文件

该阶段既可以使用系统提供的类加载器完成，也可以由**用户自定义的类加载器**来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。
加载阶段完成后，虚拟机外部的** 二进制字节流**就按照虚拟机所需的格式存储在**方法区**之中，而且在Java堆中也创建一个**java.lang.Class类的对象**，这样便可以通过该对象访问方法区中的这些数据。
## 连接
连接又包含三块内容：验证、准备、解析。
### 验证
验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。

1. 文件格式的验证：**验证字节流是否符合Class文件格式的规范**，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
2. 元数据验证：对类的元数据信息**进行语义校验**（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
3. 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
4. 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机**将符号引用转化为直接引用**的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。
### 准备
准备阶段是正式为类变量**分配内存**并**设置类变量初始值**的阶段，这些内存都将在方法区中进行分配。

1. 这时候进行内存分配的仅包括**类变量（static）**，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 这里所设置的初始值通常情况下是**数据类型默认的零值**（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
### 解析
解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。
符号引用（Symbolic Reference）：符号引用以**一组符号**来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。
直接引用（Direct Reference）：直接引用可以是**直接指向目标的指针**、**相对偏移量**或是一个**能间接定位到目标的句柄**。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

1. 类或接口的解析：判断所要转化成的直接引用是数组类型，还是普通的对象类型的引用，从而进行不同的解析。
2. 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
3. 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。
4. 接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。
## 初始化
类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
初始化，为类的静态变量**赋予正确的初始值**，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

1. 声明类变量时指定初始值
2. 使用静态代码块为类变量指定初始值

**JVM初始化步骤**

1. 假如这个类还没有被加载和连接，则程序**先加载**并**连接**该类
2. 假如该类的直接父类还没有被初始化，则**先初始化其直接父类**
3. 假如类中有初始化语句，则系统依次执行这些初始化语句

初始化阶段时执行**类构造器方法()**的过程。

1. 类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。
2. 类构造器方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的类构造器方法执行之前，父类的类构造器方法已经执行完毕，因此在虚拟机中**第一个执行的类构造器方法的类一定是java.lang.Object。**
3. 由于父类的类构造器方法方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的变量赋值操作。**
4. 类构造器方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成类构造器方法。
5. 接口中可能会有变量赋值操作，因此接口也会生成类构造器方法。但是接口与类不同，执行接口的类构造器方法不需要先执行父接口的类构造器方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的类构造器方法。
6. 虚拟机会保证一个类的类构造器方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的类构造器方法，其它线程都需要阻塞等待，直到活动线程执行类构造器方法完毕。如果在一个类的类构造器方法中有耗时很长的操作，那么就可能造成多个进程阻塞。
## 卸载
在以下情况的时候，Java虚拟机会结束生命周期 

1. 执行了System.exit()方法
2. 程序正常执行结束
3. 程序在执行过程中遇到了异常或错误而异常终止
4. 由于操作系统出现错误而导致Java虚拟机进程终止
# 类何时开始加载
通过上面的分析我们知道，类的加载和初始化是两个不同的阶段。类的加载是类生命周期的第一个阶段。
类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。

1. 只要有其它类引用了它就加载
2. 等到类初始化发生的时候才加载
:::info
这里暂时不是很理解
:::
# 类何时开始初始化
类的初始化是类加载，连接之后的阶段，主要对类变量赋予初始值。
如下情况均会对类进行初始化：

1. 创建类的实例
2. 访问类的静态变量（被final修饰的静态变量【常量】除外）
3. 访问类的静态方法
4. 反射
5. 当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化
6. 虚拟机启动时，定义了main()方法的那个类先初始化
## 特殊情况

1. 子类调用父类的静态变量

通过子类调用父类的静态变量，子类不会被初始化，但是子类会被加载。
```java
public class Parent {
    static {
        System.out.println("Parent init");
    }
    public static int v = 100;
}
public class Child extends Parent {
    static {
        System.out.println("Child init");
    }
}
public class UseParent {
    public static void main(String[] args) {
        //子类调用父类的静态方法
        System.out.println(Child.v);
    }
}

```

2. 直接调用某个类的常量

直接调用某个类的final修饰的静态变量，不但不会初始化该类，连加载都不会。
```java
public class FinalFieldClass {
    public static final String constString = "CONST";
    static {
        System.out.println("FinalFieldClass init");
    }
}
public class UseFinalField {
    public static void main(String[] args) {
        System.out.println(FinalFieldClass.constString);
    }
}

```

# 什么是懒加载
懒加载其实就是延时加载，即当对象需要用到的时候再去加载。

# 直接引用和符号引用
[https://juejin.cn/post/6844903933337403405](https://juejin.cn/post/6844903933337403405)



