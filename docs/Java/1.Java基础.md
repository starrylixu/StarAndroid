
# 泛型中的extends和super的区别
[【Java】泛型中 extends 和 super 的区别？](https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/)
<? extends T>和<? super T>是泛型中的“通配符”和“边界”的概念。
<? extends T>：是指“上界通配符”，不能往里存，只能往外取。
<? super T>：是指“下界通配符”，不影响往里存，但往外取只能放在Object对象里。
**PECS原则：频繁往外读取内容，适合用上界Extends，经常往里插入的，适合用下界Super。**
# 
# 静态属性和静态方法是否可以被继承？是否可以被重写？
静态属性和静态方法可以被继承，但是没有被重写而是被**隐藏。**
```java

public class Parent {
    public String normalStr = "Normal member of parent.";
    public static String staticStr = "Static member of parent.";

    public void normalMethod(){
        System.out.println("Normal method of parent.");
    }

    public static void staticMethod(){
        System.out.println("Static method of parent.");
    }
}
```
```java

public class Child extends Parent {
   public String normalStr = "Normal member of child.";
   public static String staticStr = "Static member of child.";

    public void normalMethod(){
        System.out.println("Normal method of child.");
    }

    public static void staticMethod(){
        System.out.println("Static method of child.");
    }
}

```
```java
package 静态属性与方法;
public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        System.out.println(child.normalStr);
        System.out.println(Child.staticStr);
        child.normalMethod();
        Child.staticMethod();

        System.out.println("-------------------------------------------------");

        Parent child1 = new Child();
        System.out.println(child1.normalStr);
        System.out.println(Parent.staticStr);
        child1.normalMethod();
        Parent.staticMethod();
    }
}

```
如果Child中没有写父类的同名属性和方法，那么输出是这样的：
通过前四行可以得出结论，静态属性和方法是可以被继承的。
```markdown
Normal member of parent.
Static member of parent.
Normal method of parent.
Static method of parent.
-------------------------------------------------
Normal member of parent.
Static member of parent.
Normal method of parent.
Static method of parent.
```
如果Child中写了父类的同名属性和方法，那么输出是这样的：
根据前四行我们可知道，虽然静态属性和方法可以被继承，但是**如果一个子类定义了一个和父类静态方法中相同的方法（即方法名，参数和返回类型相同），则该类隐藏了父类中的这个方法。**因此通过子类对象调用这些属性和方法最终调用的都是子类对象中的属性和方法。
而该隐藏的静态方法是否被调用，取决于是父类（引用）还是子类（引用）调用了该静态方法。如果是子类对象调用该静态方法那么调用的就是子类对象的静态方法，如果是父类对象调用该静态方法那么就会调用到隐藏的静态方法。可以通过第四行的输出和第九行的输出得出此结论。
```markdown
Normal member of child.
Static member of child.
Normal method of child.
Static method of child.
-------------------------------------------------
Normal member of parent.
Static member of parent.
Normal method of child.
Static method of parent.
```
结论
**对于非静态的属性和方法**
对于非静态属性，子类可以继承父类的非静态属性。但是当子类和父类有相同的非静态属性时，并没有重写并覆盖父类的非静态属性，只是隐藏了父类的非静态属性。（1，6）
对于非静态的方法，子类可以继承父类的非静态方法并可以重写覆盖父类的非静态属性方法。（3，8）
**对于静态的属性和方法**
对于静态的属性，子类可以继承父类的静态属性。但是和非静态的属性一样，会被隐藏。（2，7）
对于静态的方法，子类可以继承父类的静态方法。但是子类不可重写覆盖父类的静态方法，子类的同名静态方法会隐藏父类的静态方法。（4，9）
# Java深拷贝与浅拷贝详解

1. 实现对象拷贝的方式
2. 浅拷贝和深拷贝的区别

[【Java深入】深拷贝与浅拷贝详解_白夜行515的博客-CSDN博客](https://blog.csdn.net/baiye_xing/article/details/71788741)
# 常见的编码方式
[为什么要编码？编码的类型？乱码的产生？ - 潜跃 - 博客园](https://www.cnblogs.com/heikedeblack/p/14285289.html)
为什么要编码？
计算机只能识别01数字，我们需要将常用的字符用01来表示。一开始用一个字节的低7位表示常用的数字、字母和符号，但是不够用而出现多种编码方式。
ASCII
总共有128个，用一个字节的低七位表示，0 - 31是控制字符，如回车键、换行等等。32 - 126是打印字符，可以通过键盘输入并且能够显示出来。
ISO-8859-1
ISO组织在ASCII码基础上又制定了一些列标准用来扩展ASCII编码，其中IS-8859-1涵盖了大多数西欧语言字符，单字节编码，总共表示256个字节，应用广泛。
UTF-8
是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。而汉字用UTF-8编码是需要三个字节。这也是为什么UTF-8和GBK之间中文老是乱码。
GBK
GBK的中文编码是双字节来表示的，英文编码是用ASCII码表示的，既用单字节表示。GBK是一种国标扩展的编码方式，在之前还有一种GB2312，它只是在ASCII码的基础上做了扩展，解决汉字编码乱码的问题，总收录的六千个汉字。而GBK则在GB2312的基础上扩展总共两万字，因此GBK是完全向下兼容GB2312的。
# Java中的异常体系

1. 什么是异常
2. Java的异常体系 错误、运行时异常、编译时异常
3. Java异常关键字
4. Java异常处理流程  抛出异常、捕获异常

[java异常面试题（2021最新版） - 腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1819397?from=10680)
# Java中的反射机制

1. 什么是反射（动态编译）
2. 反射的使用[Java-反射的理解与使用-(原创)](https://www.jianshu.com/p/2302ad5dbfad)
3. 反射的原理[深入理解Java反射机制原理、使用方法_涝山道士的博客-CSDN博客_反射调用属性的原理](https://blog.csdn.net/HO1_K/article/details/81210947)
4. 为什么需要反射（反射的作用和应用场景）

[Java中为什么需要反射？反射要解决什么问题？ - buoge - 博客园](https://www.cnblogs.com/buoge/p/9285142.html#:~:text=%20%E5%8F%8D%E5%B0%84%EF%BC%88reflection%EF%BC%89%E5%85%81%E8%AE%B8%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%88runtime%EF%BC%89%E6%A3%80%E6%9F%A5%E3%80%81%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E8%A1%8C%E4%B8%BA%E3%80%82,%E5%9C%A8%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E5%AE%83%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%82%20%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E9%83%BD%E4%BF%9D%E5%AD%98%E5%88%B0%E4%BA%86class%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%87%86%E7%A1%AE%E6%97%A0%E8%AF%AF%EF%BC%9B%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E8%A1%8C%E4%B8%BA%E9%83%BD%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E3%80%82%20%E5%A6%82%E6%9E%9C%E6%83%B3%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84%E8%BF%99%E4%B8%9C%E8%A5%BF%E4%BA%86%E3%80%82)

5. 反射的缺点[为什么需要Java反射？_tongdanping的博客-CSDN博客](https://blog.csdn.net/tongdanping/article/details/103252352)
6. Android反射的应用[Java反射以及在Android中的特殊应用](https://www.jianshu.com/p/8f394d90a85c)
7. 如何监控Activity的创建和启动过程？（利用反射）

反射机制是为了能够动态编译，在运行的时候确定变量的类型。可以动态的创建对象并调用对象的属性和方法。
应用场景：

1. 没有Java源文件，无法new
2. 动态加载，降低代码耦合度，比如设计模式中就大量的使用了反射实现开闭原则
# 抽象类与接口的区别？
 [https://zhuanlan.zhihu.com/p/94770324](https://zhuanlan.zhihu.com/p/94770324)
# 分别讲讲 final，static，synchronized关键字可以修饰什么，以及修饰后的作用？ 请简述一下String、StringBuffer和StringBuilder的区别？ 
[this、super、final、static、synchronized 关键字可以修饰什么，以及修饰后的作用？_HoukHan的博客-CSDN博客](https://blog.csdn.net/qq_38127722/article/details/107013476)
如何理解final所修饰的对象的引用不能变，而对象本身可以变呢？
```java

final Person person=new Person("wangyi");
System.out.println(person.hashCode());
person.name="1234";
System.out.println(person.hashCode());

/**
 *  报错：Cannot assign a value to final variable 'person' */
person=new Person("333");
System.out.println(person.hashCode());
```
# “equals”与“==”、“hashCode”的区别和使用场景？
[Java中Native关键字的作用 - 不会就问咯 - 博客园](https://www.cnblogs.com/KingIceMou/p/7239668.html) 
[（JAVA面试）equals()和hashcode() 方法的区别_hashcode和equals方法的区别与联系_颜颜颜颜颜越的博客-CSDN博客](https://blog.csdn.net/NuanShuTT/article/details/108035777)
首先equals和hashcode定义在**基类Object**中，
在Object类中它的作用是为不同的对象**返回一个不同的整数**
而equals则是比较两个引用**是否指向同一个对象**，即比较地址是否相同，这里的equals和==没有区别（因为equals内部就是通过==去比较this和obj）。
而这样的equals是没有意义的，因为创建的两个对象的地址肯定是不同的，equals会永远返回false
```java

//对于任何非空的参考值x当且仅当x和y引用同一对象（x==y的值为真）。
public boolean equals(Object obj) {
    return (this == obj);
}

//由类Object定义的hashCode方法确实为不同的对象返回不同的整数。
//（这通常是通过将对象的内部地址转换为整数来实现的)
public native int hashCode();

```
所以Java中的类都重写了hashCode和equals。而在String中equals比较的是对象的值。重写了hashcode与equals保证了当equals比较为true时，返回的hashcode相等。
```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```
 深入思考：在设计一个类的时候，如果需要比较操作，需要保证：
如果两个对象相同，那么它们的hashCode值一定要相同
如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。
equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。（因为哈希码的生成可能存在冲突）
# Java 中深拷贝与浅拷贝的区别？ 
[Java深入理解深拷贝和浅拷贝区别_深拷贝和浅拷贝的区别_老周聊架构的博客-CSDN博客](https://blog.csdn.net/riemann_/article/details/87217229)
浅拷贝和深拷贝都是对象拷贝，拷贝的是对象，会给拷贝的对象分配一个新的地址。（引用拷贝：把原来对象的地址赋给一个新的引用变量，不会创建新的对象）
浅拷贝只拷贝对象的基本变量，而不会拷贝对象的引用变量（对其他对象的引用），即浅拷贝不会拷贝对象里面的对象。
深拷贝都会拷贝
实现浅拷贝可以用Java自带的Cloneable接口，调用clone()方法
实现深拷贝可以使用序列化

# 谈谈Error和Exception的区别？ 

# 
# 谈谈如何重写equals()方法？为什么还要重写hashCode()？ 
因为hashCode的返回值是根据传入值生成的一个整数（默认是根据对象的地址生成一个整数），因此比较两个对象的hashCode可以确定它们是否是同一对象。
为什么还需要equals是因为，**不同对象的 hashCode 可能相同；但 hashCode 不同的对象一定不相等。**
**重写了equals是为了不再比较两个对象的地址，使比较有意义**
**equals和hashCode是为了协同判断两个对象是否相等，**如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会先去执行重写的 hashCode 方法，此时对比的是两个对象的**所有属性的 hashCode 是否相同**，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了
[面试官：重写 equals 时为什么一定要重写 hashCode？ - 腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1910930)

1. 效率问题
2. 冲突问题

基本概念：

1. Java中的任何一个对象都有一个native的hashcode方法，这个方法在散列集合中会用到，比如HashTable和HashMap这些，当添加元素的时候，需要判断元素是否存在。如果直接使用equals的话效率太低了，所以一般是直接使用对象的hashcode的值进行取模运算，添加元素时，如果没有这个对象的hashcode对应的值，那么就可以直接把这个对象存进去，不用再进行任何比较；

而如果存在的话，就需要调用它的equals方法与新的元素的进行比较，相同的话就进行覆盖，不相同就直接		散列到其他位置，这样的话调用equals的次数就大大降低了

2. 如果没有重写equals方法，通过等于号比较的是两个对象的内存地址，如果相等，说明两个对象的内存地址是相同的，因为hashcode其实是根据内存地址生成的一个随机数，所以两个对象的hashcode值也是一定相等的
3. 而只重写了equals方法，不重写hashcode方法，那么就可能导致a.equals(b)==true成立，但是hashcode却不同。那么在进行散列存储这个对象的时候，可能导致两个完全相同的对象散列在不同的位置，那么在根据这个对象获取数据的时候，就会出现不可预知的错误，因为不知道到底获取哪个对象。
# 谈谈你对Java泛型中类型擦除的理解，并说说其局限性？ 
泛型擦除就是类型的参数只存在于编译器，在运行时JVM并不知道泛型的存在
如在运行时ArrayList<String>与ArrayList<Integer>的类型在JVM眼中是一样的，都是ArrayList.
[面试官：说说什么是泛型的类型擦除？ - 掘金](https://juejin.cn/post/6999797611146248222)
[Java泛型的局限性_关于泛型的局限性说法不正确的是( )_代码_李的博客-CSDN博客](https://blog.csdn.net/limengliang4007/article/details/76299500)
# String为什么要设计成不可变的？ 
第一：在Java程序中String类型是使用最多的，这就牵扯到大量的增删改查，每次增删改差之前其实jvm需要检查一下这个String对象的安全性，就是通过hashcode，当设计成不可变对象时候，就保证了每次增删改查的hashcode的唯一性，也就可以放心的操作。
第二：网络连接地址URL,文件路径path通常情况下都是以String类型保存, 假若String不是固定不变的,将会引起各种安全隐患。就好比我们的密码不能以String的类型保存，，如果你将密码以明文的形式保存成字符串，那么它将一直留在内存中，直到垃圾收集器把它清除。而由于字符串被放在字符串缓冲池中以方便重复使用，所以它就可能在内存中被保留很长时间，而这将导致安全隐患
第三：字符串值是被保留在常量池中的，也就是说假若字符串对象允许改变,那么将会导致各种逻辑错误
[面试必问：Java中String类型为什么设计成不可变的？](https://zhuanlan.zhihu.com/p/75577371)
# 说说你对Java注解的理解？ 

1. 什么是注解[Java基础 ：反射、注解、代理、线程池、依赖的学习和理解](https://www.jianshu.com/p/8da24b7cf443)

注解是一种标记，这些标记可以在编译和运行的时候被读取，通过添加Annotation，我们可以在不改变原有逻辑的情况下加入新的信息。
注解一个特殊的类，它的形式很像接口，通过@inteface关键字，定义一个注解
注解的分类：系统注解、元注解、自定义注解

2. 注解的基本使用[Java面试---Day5_Liknananana的博客-CSDN博客](https://blog.csdn.net/weixin_45882303/article/details/122630884)
3. 为什么需要注解，注解的意义何在？[Java注解Annotation基础 - Java开发 - 开发语言与工具 - 深度开源](https://www.open-open.com/lib/view/open1423558996951.html)
4. 反射+注解  依赖注入[Java基础 ：反射、注解、代理、线程池、依赖的学习和理解](https://www.jianshu.com/p/8da24b7cf443)
   1. 什么是依赖注入[反射、注解与依赖注入总结](https://www.jianshu.com/p/24820bf3df5c)
   2. 依赖注入的使用场景[用Dagger2在Android中实现依赖注入](https://www.jianshu.com/p/f713dd40e037)
# 谈一谈Java成员变量，局部变量和静态变量的创建和回收时机？ 
成员变量：在对象创建的时候会创建，在对象销毁的时候被回收，生命周期随对象的一致，存在于对象的堆内存中
局部变量：在方法调用的时候创建，在方法调用结束的时候被回收，存在于栈内存中
静态变量：在类加载的时候就被创建了，类被销毁时静态变量被回收

 
