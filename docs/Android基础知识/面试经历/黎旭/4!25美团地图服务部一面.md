1. 自我介绍
2. 闲聊
   1. 两个项目是基于什么背景开发的
   2. Java的技术是如何学习的呢？
   3. 主流的后端的框架的学习途径有哪些？
   4. Android的学习是怎样的，通过哪些途径去学习和了解Android方向的新技术和架构（视频+网盘+博客）
   5. Android大版本的适配，11升级12需要做些什么样的适配。
   6. 那有了解不同版本中的适配应该怎么做呢？
3. 进程和线程有什么关系
4. 进程之间有哪些通信方式
5. 两个Activity间怎么通信
6. 通过Intent传输数据可以传递对象吗
7. HashMap的内部结构有了解吗
   1. 红黑树和链表是在什么时候使用呢
   2. 红黑树可以再退化成链表吗，什么时候呢（这里没答出来，阈值）
8. Java中的线程同步的方法
9. synchronized修饰成员方法和静态方法有什么区别
10. volatile有了解吗，它能保证原子性吗
11. 你有提到指令重排，你能介绍一下吗（讲的双重检测锁的单例模式下的指令重排问题）
12. Activity和Fragment的生命周期有哪些区别
13. 


算法又没写出来，寄啊
![image.png](/images/8e65a424c8e38ae3e699cf2b14edf52a.png)



# 进程与线程的区别
进程（Process）是操作系统中正在运行的一个程序，它可以包含多个线程（Thread），一个进程可以拥有多个线程并行执行不同的任务。线程是进程中的一个执行单元，它可以独立执行一个指定的代码块。

一个进程可以包含多个线程，而多个线程共享同一个进程的资源，包括内存空间、打开的文件、已经加载的库等。线程之间可以通过共享内存进行通信，也可以通过操作系统提供的进程间通信（IPC）机制进行通信。线程的切换成本较低，可以在同一个进程中快速地切换上下文执行不同的任务。

在 Android 中，每个应用程序都运行在自己的进程中，每个应用程序中的组件（Activity、Service、BroadcastReceiver、ContentProvider）运行在主线程中，因此需要避免在主线程中执行耗时操作，否则会导致 UI 卡顿、ANR 等问题。因此，Android 开发者需要合理地使用线程和进程，以保证应用程序的性能和稳定性。
## 协程与线程的区别
协程和线程都是**并发编程**的概念，但它们在实现方式和运行机制上存在一些区别。
1.实现方式：线程是由**操作系统内核进行调度和管理**的，它是一种操作系统级别的并发机制。而协程是在**用户空间上实现**的，并不需要操作系统的干预，可以看作是更高级的并发机制。
2.调度方式：线程的调度是**由操作系统内核控制的**，它负责将线程切换到处理器上执行。而协程的调度是由开发人员明确控制的，可以通过代码中的特定操作来切换执行的协程。
3.并发性能：由于线程的调度是由操作系统内核负责，线程的切换涉及到用户态和内核态之间的切换，这个过程需要消耗一定的时间和资源。相比之下，协程的切换只涉及用户态，其切换成本更低。
4.阻塞与非阻塞：在传统的线程模型中，**当一个线程进行阻塞操作时（如IO或等待锁），整个线程都会被阻塞，无法执行其他任务**。而协程是基于非阻塞的原理，当一个协程遇到阻塞操作时，它会暂停自己的执行并切换到其他可执行的协程上，从而实现更高效的并发处理。
5.编程模型：在线程模型中，通常通过共享内存来实现多个线程之间的通信和同步，这样可能引发并发安全性的问题，需要使用锁等机制来保证数据一致性。相比之下，协程通常使用基于消息传递的方式来进行通信和同步，避免了共享内存的问题，并提供了更简洁的编程模型。
总体而言，**协程是一种轻量级、高效和可控的并发机制**，它通过避免线程切换的开销、提供更高层次的抽象和简化编程模型来实现高并发性能和更好的代码可读性。协程在某些情况下可以替代线程来实现并发，尤其适用于I/O密集型操作、事件驱动等场景。
# 进程间通信的方式
## 在计算机中
在计算机中，进程通信的方式有以下几种：

1. 管道：管道是一种半双工的通信方式，只能用于具有亲缘关系的进程间通信，如父进程和子进程之间。
2. 命名管道：命名管道是一种特殊类型的文件，可以在不具有亲缘关系的进程之间进行通信，可以实现任意两个进程之间的通信。
3. 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。
4. 信号量：信号量是一个计数器，用于控制多个进程对共享资源的访问，可以用来解决多进程之间的同步问题。
5. 共享内存：共享内存指两个或多个进程共享一个给定的存储区，进程可以直接读写共享内存中的数据，是最快的一种 IPC 方式。
6. 套接字：套接字是一种网络通信机制，可以在不同计算机之间的进程之间进行通信。
7. RPC：RPC（Remote Procedure Call）即远程过程调用，是分布式系统中常用的通信机制，可以让远程的计算机上的程序调用本地计算机上的程序。

不同的通信方式在不同的场景中有不同的优劣，需要根据具体情况选择合适的通信方式。
## android中
在 Android 中，常用的进程间通信方式有以下几种：

1.  Intent：通过 Intent 进行跨进程通信，实际上是利用了 Binder 机制，启动服务后通过 Intent 传递数据，服务端收到 Intent 后返回数据。 
2.  Messenger：一种轻量级的 IPC 机制，基于 AIDL 实现，底层仍然是 Binder 机制，支持进程间通信，可以跨进程传递 Message 对象。 
3.  AIDL（Android Interface Definition Language）：Android 接口定义语言，是 Android 独有的进程间通信机制，它基于 RPC（Remote Procedure Call）原理，可以用于定义服务端接口和客户端代理对象，实现进程间的通信。 
4.  ContentProvider：是 Android 中的一种特殊的组件，主要用于在不同应用程序之间共享数据，数据存储在 SQLite 数据库中，可以被其他应用程序读取和修改。 
5.  Socket：通过网络套接字进行进程间通信，Socket 可以实现不同设备间的通信，例如手机与电脑之间的通信。 
6.  文件共享：通过将数据存储在文件中，实现不同进程间的数据共享。 

选择何种通信方式，需要根据实际业务场景和数据传递的需求来决定。
# 两个Activity间的通信方式
在Android中，Activity间通信有多种方式，其中常见的有：

1.  通过Intent传递数据：可以使用putExtra()方法将数据存放在Intent中，然后通过startActivity()方法启动目标Activity。 
2.  使用回调函数：可以在目标Activity中定义一个回调函数接口，在启动该Activity时将一个实现该接口的对象传递给目标Activity，然后目标Activity可以在适当的时候调用该回调函数来传递数据。 
3.  使用广播：可以在发送广播时将数据放入Intent中，然后目标Activity可以注册对应的广播接收器来接收该广播并获取数据。 
4.  使用共享文件：可以将数据写入共享文件中，然后目标Activity可以读取该文件来获取数据。 
5.  使用ContentProvider：可以在应用程序中实现一个ContentProvider来提供数据，然后目标Activity可以通过调用该ContentProvider来获取数据。 

需要根据具体的场景和需求选择合适的通信方式。
## 通过Intent传输数据可以传递对象吗
这一块其实考察Serializable和Parcelable的区别
通过Intent传输数据时，可以传递对象，但需要确保对象是可序列化的或者可实现Parcelable接口。如果要传递的对象不是Java内置的数据类型或字符串等简单类型，而是自定义对象，就需要将它实现为可序列化或者Parcelable接口，以便能够被序列化为字节流或可在进程之间传输的数据结构。

使用Serializable接口实现序列化的方式是最常见的一种。该接口的实现很简单，只需要在类声明前加上"implements Serializable"关键字，该类就成为可序列化的。对于非常大的对象或者性能要求较高的场景，可以使用Parcelable接口，该接口比Serializable更高效。需要注意的是，使用Parcelable需要手动实现序列化和反序列化的过程，相对复杂一些。

在 Android 中，Serializable 和 Parcelable 都是用于实现对象序列化的接口，但是它们之间有一些区别：

1.  Serializable 是 Java 标准库中的接口，而 Parcelable 是 Android SDK 中的接口。 
2.  在序列化和反序列化的过程中，Serializable 使用了 Java 反射机制，因此相对来说效率较低，而 Parcelable 是手动实现的，相对来说效率较高。 
3.  Serializable 会在运行时动态地反射生成对象，而 Parcelable 需要开发者手动实现序列化和反序列化过程，所以 Parcelable 更加灵活和可控。 
4.  当需要在不同进程中传递数据时，只有 Parcelable 接口能够正常工作，Serializable 会出现问题。 

综上所述，Parcelable 相对来说是更优秀的序列化方式，但在某些情况下，Serializable 也是可以使用的。

Parcelable是一种比Java标准的Serializable更高效的序列化方法，主要用于Android中Intent传递对象等场景。
在实现Parcelable接口的类中，需要实现以下两个方法：

1.  writeToParcel(Parcel dest, int flags): 将对象序列化到Parcel对象中。参数dest是目标Parcel对象，flags是额外的选项，一般为0即可。 
2.  Creator CREATOR: 用于反序列化Parcelable对象的静态类，其中的createFromParcel(Parcel source)方法用于从Parcel对象中读取数据并返回Parcelable对象。 

在序列化过程中，对象的成员变量会依次写入Parcel对象中，反序列化过程中则需要按照序列化顺序依次读取。因此，Parcelable的实现需要考虑到成员变量的顺序和类型，以保证正确的序列化和反序列化。另外，Parcelable不支持跨进程序列化，如果需要在不同进程间传递对象，则需要使用其他进程间通信的方式。
# HTTP和HTTPS的区别
HTTP和HTTPS是两种不同的网络传输协议，其中HTTP代表超文本传输协议，而HTTPS代表安全套接字层超文本传输协议。
HTTP协议是一种无状态协议，它通过在客户端和服务器之间传输消息来实现通信。HTTP协议使用TCP协议作为传输层协议，通常使用80端口进行通信。HTTP协议传输的数据是明文的，容易被第三方窃取和篡改，因此不适合传输敏感数据。
HTTPS协议是在HTTP协议的基础上加入了SSL/TLS协议进行**数据加密**和**身份验证**。HTTPS协议使用TCP协议作为传输层协议，通常使用443端口进行通信。HTTPS协议通过使用**SSL/TLS协议**进行加密和身份验证，保证了数据传输的安全性，能够有效地防止第三方窃取和篡改数据。同时，HTTPS协议还能够防止中间人攻击和DNS欺骗等安全问题。
总的来说，HTTP协议传输的数据是明文的，不安全；而HTTPS协议通过加密和身份验证，保证了数据传输的安全性，适合传输敏感数据。
## HTTPS的加密手段

HTTPS使用了SSL/TLS协议来对数据进行加密。当客户端与服务器端建立连接时，会进行一个握手过程来协商出一个对称加密算法和密钥，该对称加密算法和密钥将用于加密和解密数据。具体流程如下：

1.  客户端向服务器端发起一个连接请求，请求中包含了客户端支持的SSL/TLS版本号和加密算法。 
2.  服务器端收到连接请求后，会选择一个与客户端协商支持的加密算法和版本号相匹配的加密套件，并将该加密套件的信息发送给客户端。 
3.  客户端收到服务器端发送的加密套件信息后，会选择一个与服务器端协商支持的加密算法和版本号相匹配的加密套件，并将该加密套件的信息发送给服务器端。 
4.  客户端和服务器端都确定了使用的加密套件后，会开始进行握手过程，该过程包括证书验证、密钥协商和身份认证等步骤。 
5.  握手过程完成后，客户端和服务器端将开始使用对称加密算法和密钥来加密和解密数据。 

在上述流程中，服务器端需要提供一份数字证书，该证书包含了服务器的公钥以及一些证书信息。客户端在收到证书后，会验证该证书的合法性，包括证书是否过期、证书是否由可信的证书颁发机构签发等，如果验证通过，客户端会从证书中获取服务器的公钥，并将公钥用于加密协商密钥的过程。由于公钥加密是一种非常慢的操作，因此在握手过程中使用了非对称加密和对称加密相结合的方式，提高了握手过程的效率。

# TCP和UDP的区别
TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种不同的传输层协议，它们在网络通信中有以下区别：

1.  连接方式：TCP是面向连接的协议，UDP是无连接的协议。TCP通过三次握手建立连接，而UDP没有连接的概念，发送数据前不需要建立连接。 
2.  数据传输的可靠性：TCP提供可靠的数据传输，确保数据的完整性和可靠性；而UDP不保证数据的可靠性，数据传输过程中可能会丢失、重复或者乱序。 
3.  数据传输的效率：由于TCP提供可靠的数据传输，因此它的传输效率相对较低，而UDP则没有TCP的流量控制、拥塞控制等机制，传输效率较高。 
4.  应用场景：由于TCP的可靠性和稳定性，它适用于对数据传输可靠性要求较高的场景，例如文件传输、邮件发送等；而UDP适用于对实时性要求较高的场景，例如音视频传输、游戏等。 

总的来说，TCP提供可靠的数据传输，而UDP提供更高效的数据传输。
# ArrayList和LinkedList的区别
ArrayList和LinkedList是Java集合框架中常用的两种List实现，它们的区别主要体现在以下几个方面：

1.  内部实现方式不同：ArrayList底层是通过数组实现的，而LinkedList底层是通过链表实现的。 
2.  访问元素的速度不同：ArrayList通过下标访问元素时速度较快，时间复杂度为O(1)，而LinkedList访问元素的速度较慢，时间复杂度为O(n)。 
3.  插入和删除元素的速度不同：在ArrayList中，如果要在中间插入或删除元素，需要将后面的元素都向后移动或向前移动，时间复杂度为O(n)；而在LinkedList中，插入或删除一个元素只需要改变该元素前后元素的指针即可，时间复杂度为O(1)。 
4.  内存占用不同：ArrayList的每个元素占用固定的内存空间，所以在存储大量数据时可能会浪费内存；而LinkedList的每个元素只需要保存指向前后元素的指针，所以在存储大量数据时内存占用相对较小。 

综上所述，如果需要随机访问元素，可以选择ArrayList；如果需要频繁插入和删除元素，可以选择LinkedList。

# Java中线程同步的方法
Java中线程同步的方法有以下几种：

1.  **synchronized关键字：**使用synchronized修饰的方法或代码块，能够保证同一时间只有一个线程访问该代码块或方法。当线程进入synchronized代码块或方法时，会自动获取该对象的锁，其他线程无法访问，直到该线程执行完毕释放锁后，其他线程才能继续访问。 
2. ** ReentrantLock类：**ReentrantLock是JDK提供的一种高级的同步工具类，它比synchronized关键字更加灵活，具有可重入、可中断、公平锁等特性。与synchronized不同，ReentrantLock需要手动加锁和解锁。 
3.  **volatile关键字**：使用volatile修饰的变量，能够保证在多线程环境下对该变量的操作是原子性的。volatile关键字能够保证变量的可见性和顺序性，但是不能保证对该变量的操作是原子性的。 
4.  **wait()、notify()和notifyAll()**方法：这三个方法是Object类中的方法，用于线程之间的通信。wait()方法使线程进入等待状态，并释放当前持有的锁；notify()方法唤醒一个处于等待状态的线程，notifyAll()方法唤醒所有处于等待状态的线程。 
5.  **CountDownLatch**类：CountDownLatch是JDK提供的一种同步工具类，用于控制一个或多个线程等待多个线程的完成。它的原理是在一个线程等待多个线程完成的场景中，设置一个计数器，每个线程完成后计数器减1，当计数器为0时，等待的线程可以继续执行。 
6.  CyclicBarrier类：CyclicBarrier也是JDK提供的一种同步工具类，它能够让一组线程在到达一个屏障时被阻塞，直到所有线程都到达屏障后才能继续执行。与CountDownLatch不同的是，CyclicBarrier能够重复使用，当所有线程都到达屏障时，计数器会重置为初始值，继续等待下一轮。 
7.  **Semaphore**类：Semaphore是JDK提供的一种同步工具类，用于控制对某个资源的访问权限。它的原理是在对某个资源的访问上设置一个计数器，每个线程访问该资源时，计数器减1，当计数器为0时，其他线程无法访问该资源。 
# volatile重排序和可见性
## 重排序
是的，volatile可以部分解决编译器重排序的问题。在Java语言规范中，针对volatile关键字对编译器的指令重排序规定了一些特殊的约束，确保编译器在编译时不会对volatile变量的顺序进行重排，从而保证指令的顺序与程序的顺序一致。
具体来说，volatile变量的写操作会在写操作本身及其之前的所有操作完成后执行，而读操作会在读操作本身及其之前的所有操作完成后执行。这意味着在写操作完成前，其它线程不会看到这个写操作所更新的变量值。同样，在读操作完成前，其它线程不会看到这个读操作所读取的变量值。
但是，volatile并不能完全解决多线程环境下的并发问题，比如说不同线程之间的竞态条件、原子性问题等。这些问题需要使用其它的并发控制机制来解决。
## 可见性
在 Java 中，`volatile` 是一种关键字，用于修饰变量。在多线程编程中，`volatile` 用来保证线程之间对变量进行读写操作时的可见性，即当一个线程修改了某个变量的值，其他线程能够立即看到该变量的最新值，从而避免出现数据不一致的情况。
具体来说，当一个变量被声明为 `volatile` 后，它的值的修改会立即刷新到主内存中，同时其他线程读取该变量的值时会先从主内存中读取最新的值，而不是从线程的本地缓存中读取旧的值。这样就能保证所有线程都能看到该变量的最新值。
需要注意的是，**虽然 `volatile` 可以保证可见性，但是它并不能保证线程安全**，即仅靠 `volatile` 关键字不能解决多线程并发访问同一变量时可能出现的问题，需要配合其他机制，如锁机制等来保证线程安全。

# 为什么volatile不能保证原子性
虽然 `volatile` 关键字可以保证内存可见性，但是它并不能保证对变量操作的原子性。
在多线程环境下，如果多个线程同时对同一个变量进行操作，可能会导致其中一个线程的操作结果被覆盖，从而出现错误的结果。
例如，假设有两个线程同时对一个变量 `count` 进行自增操作，代码如下：

```
count++;
```
这段代码看似简单，但实际上它包含了三个步骤：

1. 从内存中读取 `count` 的值。
2. 对 `count` 的值加 1。
3. 将结果写回到内存。

由于这三个步骤不是原子性的，也就是说在执行这段代码时，可能会发生以下情况：

1. 线程 A 读取 `count` 的值为 1。
2. 线程 B 读取 `count` 的值也为 1。
3. 线程 A 对 `count` 的值加 1，结果为 2。
4. 线程 A 将结果 2 写回内存。
5. 线程 B 对 `count` 的值加 1，结果也为 2。
6. 线程 B 将结果 2 写回内存，覆盖了线程 A 的结果。

这种情况就是线程安全问题，因此需要采用线程同步机制，比如使用 `synchronized` 关键字或者使用原子类来保证变量的操作是原子性的。

# 单例模式下指令重排的问题
在双重检测锁下的单例模式中，如果没有使用`volatile`关键字来修饰实例变量，可能会发生指令重排序，导致获取到未完成初始化的实例，从而出现线程安全问题。

具体地说，当一个线程在进行第一次检测时，发现实例变量没有被初始化，于是它会获取锁并开始初始化实例。然而，在实例化过程中，JVM会进行指令重排序，可能会把实例变量的初始化和对象的引用赋值操作交换执行顺序。如果此时发生线程切换，另一个线程也会进入第一次检测，发现实例变量已经被赋值了，于是直接返回实例。但是由于指令重排的存在，这个实例可能并没有完成初始化，从而出现线程安全问题。

因此，为了避免这种问题，需要使用`volatile`关键字来修饰实例变量，从而禁止JVM对指令进行重排序。

# Activity和Fragment
Fragment是Android中的组件之一，它具有自己的生命周期。下面是Fragment各个生命周期函数的区别：

1.  `onAttach()`: 当Fragment与Activity建立关联时调用，表示该Fragment已经被添加到Activity中。 
2.  `onCreate()`: 当Fragment创建时调用，用于初始化该Fragment。 
3.  `onCreateView()`: 当Fragment创建其布局时调用，用于实例化该Fragment的布局。 
4.  `onActivityCreated()`: 当Fragment所在的Activity完成其onCreate()方法时调用，用于通知该Fragment所在的Activity该Fragment已经完成创建。 
5.  `onStart()`: 当Fragment可见时调用，用于启动该Fragment。 
6.  `onResume()`: 当Fragment与用户交互时调用，表示该Fragment已经可交互。 
7.  `onPause()`: 当Fragment被覆盖时调用，表示该Fragment不再与用户交互。 
8.  `onStop()`: 当Fragment不再可见时调用，用于停止该Fragment。 
9.  `onDestroyView()`: 当Fragment的视图被销毁时调用。 
10.  `onDestroy()`: 当Fragment销毁时调用，用于释放该Fragment所占用的资源。 
11.  `onDetach()`: 当Fragment与Activity解除关联时调用，表示该Fragment已经被从Activity中移除。 

需要注意的是，由于Fragment与Activity生命周期的差异，当Fragment与Activity有交互时，需要使用`onActivityCreated()`方法替代`onCreate()`方法来初始化Fragment的数据，使用`onDestroyView()`方法替代`onDestroy()`方法来释放Fragment的资源。

# Activity和Fragment的区别
Activity和Fragment是Android开发中两个重要的组件，它们有以下几点区别：

1.  生命周期：Activity的生命周期包含onCreate、onStart、onResume、onPause、onStop、onRestart、onDestroy等方法；而Fragment的生命周期包含onAttach、onCreate、onCreateView、onActivityCreated、onStart、onResume、onPause、onStop、onDestroyView、onDestroy、onDetach等方法。两者的生命周期存在一定的关联性，但也有一些不同之处。 
2.  视图结构：Activity只有一个根布局，而Fragment可以嵌套在Activity的布局中，也可以被其他Fragment嵌套，形成复杂的视图结构。 
3.  可见性：Activity作为应用的一个独立界面存在，其可见性和用户操作密切相关。而Fragment的可见性与其所依赖的Activity以及Fragment自身的状态相关。 
4.  生命周期调用方式：Activity的生命周期方法是由系统直接调用的，而Fragment的生命周期方法是由其所依赖的Activity的生命周期方法间接调用的。 
5.  通信方式：Activity之间可以通过Intent传递数据和启动其他Activity，Fragment之间可以通过FragmentManager进行通信，也可以通过其所依赖的Activity进行通信。 
6.  共享数据：Activity之间可以通过Intent传递数据，也可以使用共享Preference、文件、数据库等方式共享数据。Fragment之间可以使用Bundle、ViewModel、静态变量等方式共享数据。 
7.  可重用性：Fragment具有很好的可重用性，可以在多个Activity中复用。Activity的可重用性相对较差，一般只能在同一个应用程序内部复用。 
# Handler机制
Android中的Handler机制主要用于实现异步消息处理和线程间通信，通常用于解决在UI线程中执行耗时操作导致界面卡顿的问题。

Handler机制的核心是Handler、Message、MessageQueue和Looper。

1. Handler是消息处理器，负责发送和处理消息，它通常运行在主线程中，用于更新UI或执行其他需要在主线程中执行的操作。
2. Message是消息的载体，它包含了要发送的消息内容，例如一个数据对象或者一个Runnable对象。
3. MessageQueue是消息队列，用于存放Message对象。当消息被发送时，会被添加到消息队列中，等待Handler处理。在 Android 中，MessageQueue 实现使用的是**双向链表**。它是通过一个双向链表维护所有待处理消息的队列，并且每个线程都有一个 MessageQueue。当 Handler 发送一个 Message 时，它会被加入到 MessageQueue 的队尾。然后 Looper 不断地从队列的队头取出 Message，然后分发给对应的 Handler 进行处理。当 MessageQueue 中没有任何 Message 时，Looper 就会进入睡眠状态，等待新的 Message 的到来。
4. Looper是消息循环器，用于不断地从MessageQueue中取出消息，并交给Handler处理。Looper.loop()方法是一个无限循环，它会一直阻塞等待新的消息到来，直到线程被中断或者quit()方法被调用。

通过使用Handler机制，我们可以将任务发送到MessageQueue中，然后在Looper线程中处理这些消息，从而实现异步处理和线程间通信。同时，我们还可以使用Handler.postDelayed()方法实现延时执行任务的功能。

# 子线程发送的消息子线程能处理吗
可以处理，但是需要在子线程中**使用自己的Looper来创建Handler实例**，这样就能够在子线程中处理来自子线程的消息了。具体步骤如下：

1.  在子线程中调用Looper.prepare()来创建自己的Looper实例。 
2.  调用Looper.loop()方法来使得该子线程处于消息循环状态。 
3.  在子线程中创建Handler实例，并将其绑定到该子线程的Looper实例上。 
4.  在子线程中发送消息到Handler，Handler会自动将该消息放入该子线程的消息队列中。 
5.  在子线程的消息循环中，Handler会从该子线程的消息队列中取出消息，并执行相应的操作。 

需要注意的是，如果在子线程中没有调用Looper.prepare()和Looper.loop()方法创建消息循环，那么在子线程中发送消息到Handler是无效的，因为没有消息循环来处理这些消息。

# Handler先发送一个延时10秒的消息，再发送一个立刻处理的消息，Handler是如何做到先处理这个要求立刻处理的消息的

# 了解过ANR吗，什么条件会出现ANR


