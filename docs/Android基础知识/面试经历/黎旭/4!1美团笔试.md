**时间限制：** 3000MS**内存限制：** 589824KB
**题目描述：**
小美正在整理桌子上的一排装饰品。小美对待装饰品摆放方式的审美角度很奇特，她认为高度相差比较大的装饰品放在相邻位置会很难看，她想对这一排装饰品进行整理，可以交换任意两个装饰品的位置任意多次。假设当前从左到右n个装饰品的高度分别为h1,h2,...,hn，那么当前这一排装饰品的丑陋值为![image.png](/images/ea9772e57d3a2338b2337236091a01b8.png)，其中|x|为x的绝对值。小美想最小化她的装饰品的丑陋值，请你帮她排一下顺序。 形式化地来讲，有一长为n的序列a1,a2,...,an，你可以任意次数地进行交换，每次交换都可以选择任意两个不同的数i,j,交换ai,aj的位置。假设经过若干次交换后，序列变为h1,h2,...,hn，其丑陋值为 ![image.png](/images/7bfd4d120eaffa27683e2672c4c1dc26.png)，你需要找出一种交换方式，使得最终序列{hn}的丑陋值最小化。你不需要输出具体交换方式，只需要输出最终的{hn}序列的丑陋值即可。
![image.png](/images/3c9fc10e09d0148d5cacce19ce2cb439.png)
![image.png](/images/c6ce9314c2350d37b360e86ebd5979a8.png)
```java
package metuan_;

import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 */
public class Main {
    private static int n;
    private static Long[] a;
    private static Long ans=0L;
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        n=scanner.nextInt();
        a=new Long[n];
        for(int i=0;i<n;++i){
            a[i]=scanner.nextLong();
        }
        Arrays.sort(a);
        for(int i=0;i<n-1;++i){
            ans+=(Math.abs(a[i]-a[i+1]));
        }
        System.out.println(ans);
    }
}

```
![image.png](/images/48a9af236ccf5efdd92651493bc01b51.png)
![image.png](/images/72905a252b7d606588a8fb78a096cec8.png)
![image.png](/images/5bca75a62d0e412dd8eee71f30f77110.png)

```java
package metuan_;

import java.util.Scanner;


/**
 * 1≤n,m≤ 50000,opi∈{0,1},
 * 当opi=0 时,1≤xi≤n,0≤yi≤10000;
 * 当opi=1 时，1≤xi≤yi≤n。
 * 保证至少有一次opi=1
 */
public class Main1 {
    private static int n,m;
    private static int[] op,x,y,a;
    private static long[] pres;
    private static boolean flag=false;

    private static long ans=0L;
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        //初始化数据
        extracted(scanner);
        for(int i=0;i<m;++i){
            //更新操作
            if(op[i]==0){
                a[x[i]]=y[i];
                //更新前缀和数组
                for(int j=x[i];j<=n;++j){
                    pres[j]=0L+pres[j-1]+a[j];
                }
//                print();
            }else{//查询操作

//                for(int j=x[i];j<=y[i];j++){
//                    ans+=(0L+a[j]);
//                }
                ans = 0L+pres[y[i]]-pres[x[i]-1];
                if(flag==false){
                    System.out.print(ans);
                    flag=true;
                }else{
                    System.out.print(" "+ans);
                }

            }
        }

    }

    private static void print(){
        for(int i=0;i<n+1;++i){
            System.out.print(" "+pres[i]+" ");
        }
        System.out.println();
    }
    private static void extracted(Scanner scanner) {
        n= scanner.nextInt();
        m= scanner.nextInt();
        op=new int[m];
        x=new int[m];
        y=new int[m];
        a=new int[n+1];//有n个收藏夹
        pres=new long[n+1];//前缀和数组
        for(int i=0;i<m;++i){
            op[i]= scanner.nextInt();
        }
        for(int i=0;i<m;++i){
            x[i]= scanner.nextInt();
        }
        for(int i=0;i<m;++i){
            y[i]= scanner.nextInt();
        }
    }
}

```

 
