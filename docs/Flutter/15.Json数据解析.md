参考资料：[https://juejin.cn/post/7043721908801503269#heading-15](https://juejin.cn/post/7043721908801503269#heading-15)
在原生开发中，我们通常会将一个Json数据解析为一个对象实体，然后使用。这是因为Java和Kotlin拥有反射可以将Json数据映射为对应的对象实体类对象。但是Dart语言并**没有反射特性**，而是通过字典取值的方式使用Json数据，也就是map键值对取值的方式，这显然很不友好，开发者必须非常清楚Json数据的键。
但并不是毫无破局之法，我们可以”曲线救国“，既然大家习惯使用操作实体类对象，那么我们**将Json数据先转换成字典**，再**将字典手动映射到对象实体类对象**中。但是每一个实体类都去手动写映射代码，非常影响开发效率。所以就衍生了很多 Json 映射为对象实体类代码的自动生成框架。由这些框架帮助我们去生成映射代码。
这里主要介绍`**FlutterJsonBeanFactory**`**,**它是一个开发插件，具体使用如下：
# 下载插件
打开Android Studio的`Setting->Plugins`，直接搜索`FlutterJsonBeanFactory`
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696304047241-c20c4203-c6df-4e6f-9cba-9f9b12f080e5.png#averageHue=%23373b40&clientId=u7ef0f4d1-4692-4&from=paste&height=665&id=ud0429984&originHeight=997&originWidth=1472&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=147200&status=done&style=none&taskId=uf19902dc-3144-4d07-8ea5-359119e8afd&title=&width=981.3333333333334)
在项目创建目录点击New能发现`JsonToDartBeanAction`就说明安装已经成功，如果找到请重启Android Studio
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696304275304-62e005b3-784e-42d0-88b0-61445267fbb8.png#averageHue=%233d4144&clientId=u7ef0f4d1-4692-4&from=paste&height=335&id=u5f15cb4c&originHeight=502&originWidth=1204&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79416&status=done&style=none&taskId=u7fb681be-c63d-4403-a038-fa619440e35&title=&width=802.6666666666666)
# 创建实体类
点击JsonToDartBeanAction按钮，可以看到弹出了这个界面：

- ClassName：要创建的类的名称
- JsonText：需要解析的Json数据
- null-able：勾选选项表示字段都是非空的，不勾选默认可空
- default value：勾选可以为以下四种类型设置默认值

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696304865744-99c2d5e7-c8e8-4130-995c-dadc56945028.png#averageHue=%23414546&clientId=u7ef0f4d1-4692-4&from=paste&height=651&id=udebc562d&originHeight=977&originWidth=1170&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=33342&status=done&style=none&taskId=uc27196e7-1a69-4250-9cbd-36a7f652116&title=&width=780)
# 生成映射代码
可以看到生成了四个文件（绿色的）
其中`student_entity.dart`文件会生成在选中的目录下，是真正的实体类
而其他三个文件在`generated/json`目录下，这个目录结构也是生成的，其中`xx.g.dart`是辅助实体类生成的方法，而`base`目录下的两个类是基础的通用代码。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696304987706-15dcb6e3-31b0-460a-a5c1-556456d0cd5b.png#averageHue=%233e444c&clientId=u7ef0f4d1-4692-4&from=paste&height=283&id=u3b1e23b3&originHeight=424&originWidth=475&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22848&status=done&style=none&taskId=ua3da06b1-df15-4964-b0af-39cd5cf3bf5&title=&width=316.6666666666667)
如果我们再生成一个`Teacher`类的映射代码，可以看到`xxx_entity.g.dart`和`xxx_entity.dart`成对的增加。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696306015531-7aa38328-071b-46cf-bac4-99b2e572aa85.png#averageHue=%233e444a&clientId=u7ef0f4d1-4692-4&from=paste&height=323&id=u9f9f3404&originHeight=485&originWidth=538&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27221&status=done&style=none&taskId=u21e559ab-9d2e-4c6f-b1b9-55f045a48ef&title=&width=358.6666666666667)
注意：修改了xxx_entity的代码需要重新build来更新xxx_entity.g.dart的代码
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1701779452520-820755c3-1027-4ad6-bdec-0f150017cca7.png#averageHue=%232e3135&clientId=u43c809b1-af81-4&from=paste&height=140&id=u9973e590&originHeight=210&originWidth=256&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15776&status=done&style=none&taskId=u60b5cb6d-611a-4dc7-aeeb-14658fde174&title=&width=170.66666666666666)
# 解析Json
## Json单实体
类似如此的单实体Json数据
```dart
String stuData = """
     {
        "id":"12313",
        "name":"starry",
        "age":21,
        "major":"computer"
     }
    """;
```
直接调用实体类对应的 `fromJson` 方法即可将 Json 数据解析为实体对象。
`fromJson` 需要的参数是 Map ，所以需要先使用 `jsonDecode` 将 Json 字符串转换为 Map
```dart
StudentEntity student = StudentEntity.fromJson(jsonDecode(stuData));
```
除了直接使用实体类的 `fromJson` 方法外也可以直接使用生成的 `JsonConvert` 来解析：
```dart
StudentEntity? student = jsonConvert.convert<StudentEntity>(jsonDecode(stuData));

UserEntity? user = jsonConvert.asT<UserEntity>(jsonDecode(userData));

UserEntity? user = JsonConvert.fromJsonAsT<UserEntity>(jsonDecode(userData));

```
## Json数组
解析 Json 数组 数据则需要调用 `JsonConvert` 的对应方法进行解析，除了使用上面的 convert 、asT、fromJsonAsT 外，还可以使用 convertList 、convertListNotNull：
```dart
String userData = """
 [
    {
      "id":"12313",
      "name":"loongwind",
      "age":18
    },
    {
      "id":"22222",
      "name":"cmad",
      "age":25
    }
 ]
""";

List<UserEntity>? users = jsonConvert.convert<List<UserEntity>>(jsonDecode(userData));

List<UserEntity>? users = jsonConvert.asT<List<UserEntity>>(jsonDecode(userData));

List<UserEntity>? users = JsonConvert.fromJsonAsT<List<UserEntity>>(jsonDecode(userData));

List<UserEntity?>? users = jsonConvert.convertList<UserEntity>(jsonDecode(userData));

List<UserEntity>? users = jsonConvert.convertListNotNull<UserEntity>(jsonDecode(userData));

```
`convertList` 、`convertListNotNull` 与  convert 、asT、fromJsonAsT  的区别在于前者的泛型为 List Item元素的泛型类型，后者则直接为对应 List 的类型。如上面 convertList 、`convertListNotNull` 的泛型直接为 UserEntity , 而  convert 、asT、fromJsonAsT  的泛型为 List<UserEntity> 。
# JsonField的使用
开发中常常会有Json数据字段和实体类中代码字段不一致的情况，这种时候就需要使用JsonField来**实现自定义的字段映射。**
例如在Json 里的字段为 AGE 需要映射到实体类的 age 字段，只需要在实体类的 age 字段上加上 `JSONField` 注解，指定 name 为 AGE , 然后使用 `Alt + J` 重新生成代码：
```dart
 String? id;
 String? name;
 @JSONField(name: "AGE")
 int? age;
```
```dart
String stuData = """
     {
        "id":"12313",
        "name":"starry",
        "AGE":21,
        "major":"computer"
     }
    """;
StudentEntity? student = jsonConvert.convert<StudentEntity>(jsonDecode(stuData));
content: Text("${student?.name} ${student?.age.toString()}"),

```
# 封装Json
## 局限性
掌握了Json解析的基本使用，但是在实际开发中可能往往拿到的Json数据格式是这样的：
```dart
{
  "code": 200,
  "message": "success",
  "data":{
    "id": "12312312",
    "name": "loongwind",
    "age": 18
  }
}

```
在返回数据外又统一包裹了一层，data 字段的数据才是实际业务需要的数据，而不同的接口返回的 data 数据结构也不相同，如果直接使用插件生成的，会生成如下代码：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696309097542-6246980c-0a58-430d-acd9-ad5e337e46c8.png#averageHue=%232c2c2b&clientId=u08265250-b300-4&from=paste&height=545&id=udf23d085&originHeight=817&originWidth=1289&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=86309&status=done&style=none&taskId=u0a01abc0-2dd3-4495-8ab4-bd6c3e13d10&title=&width=859.3333333333334)
```dart
@JsonSerializable()
class UserResponseEntity {

	int? code;
	String? message;
	UserResponseData? data;
  
  UserResponseEntity();
  //...
}

@JsonSerializable()
class UserResponseData {

	String? id;
	String? name;
	int? age;
  
  UserResponseData();
	//...
}

```
这样的话每一个接口都要生成一个 `ResponseEntity` 类，使用起来也不方便不便于统一封装。所以需要对 `ResponseEntity` 进行改造，让其支持泛型解析。
## 定义基类Entity
首先重新使用上面的 Json 示例数据生成一个 `ApiResponseEntity` ，然后将 data 字段类型改为 `dynamic` ，使用 `Alt + J `重新生成代码：
文件如果没有自动更新可以使用这个按钮：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696309708879-57f463b1-3607-4b86-8a5b-18f790d82e59.png#averageHue=%233d4247&clientId=u08265250-b300-4&from=paste&height=158&id=u62bcdd34&originHeight=237&originWidth=339&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12995&status=done&style=none&taskId=uca8e4b6a-0d34-4d90-bd9d-649be195df1&title=&width=226)
```dart
import 'dart:convert';

import 'package:demo2/generated/json/base/json_field.dart';

import '../generated/json/api_response_entity.g.dart';

export 'package:demo2/generated/json/user_response_entity.g.dart';

@JsonSerializable()
class ApiResponseEntity {
  late int code = 0;
  late String message = '';
  late dynamic data;

  ApiResponseEntity();

  factory ApiResponseEntity.fromJson(Map<String, dynamic> json) =>
      $ApiResponseEntityFromJson(json);

  Map<String, dynamic> toJson() => $ApiResponseEntityToJson(this);

  @override
  String toString() {
    return jsonEncode(this);
  }
}

```
再将 `@JsonSerializable()` 注解去掉，把 `api_response_entity.dart` 和 `api_response_entity.g.dart` 文件放到一个单独的文件夹内，这里我把它们放在`model/base`文件下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1696309943964-d5f505b5-7ef2-4ac7-beda-2dc8d747f95e.png#averageHue=%237c8354&clientId=u08265250-b300-4&from=paste&height=304&id=ue5eff67d&originHeight=456&originWidth=1460&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=91857&status=done&style=none&taskId=u55faa5f5-88f6-46c0-95b8-89ac3b68c18&title=&width=973.3333333333334)
:::info
⚠️注意：重新生成代码会根据 ` @JsonSerializable()` 注解生成，因为需要修改 `ApiResponseEntity` 类来满足泛型解析的需求，所以要去除 `@JsonSerializable()` 注解防止重新生成代码将自定义代码覆盖掉。而去掉了 `@JsonSerializable()`  注解后，下次生成代码时会自动删除 `generated/json` 下多余的` .g.dart`，所以需要将其拷贝到其他目录防止下次生成时被删除。
:::
## 泛型支持
最后就是修改`ApiResponseEntity` 以及 `ApiResponseEntityFromJson` 添加泛型支持：
给 `ApiResponseEntity` 上加上泛型 T ，然后修改 data 类型为 T? , 再给 `$ApiResponseEntityFromJson` 方法上添加泛型，解析 data 数据的时候就可以直接使用 `jsonConvert.convert<T> `进行解析。
```dart
class ApiResponseEntity<T> {
  late int code = 0;
  late String message = '';
  late T? data;

  ApiResponseEntity();

  factory ApiResponseEntity.fromJson(Map<String, dynamic> json) =>
      $ApiResponseEntityFromJson<T>(json);

  Map<String, dynamic> toJson() => $ApiResponseEntityToJson(this);

  @override
  String toString() {
    return jsonEncode(this);
  }
}

```
直接使用 `jsonConvert.convert<T> `进行解析data数据
```dart
final T? data = jsonConvert.convert<T>(json['data']);
```
```dart
ApiResponseEntity<T> $ApiResponseEntityFromJson<T>(Map<String, dynamic> json) {
  final ApiResponseEntity<T> apiResponseEntity = ApiResponseEntity<T>();
  final int? code = jsonConvert.convert<int>(json['code']);
  if (code != null) {
    apiResponseEntity.code = code;
  }
  final String? message = jsonConvert.convert<String>(json['message']);
  if (message != null) {
    apiResponseEntity.message = message;
  }
  final T? data = jsonConvert.convert<T>(json['data']);
  if (data != null) {
    apiResponseEntity.data = data;
  }
  return apiResponseEntity;
}

//以下代码都不需要修改
Map<String, dynamic> $UserResponseDataToJson(UserResponseData entity) {
···
}

extension UserResponseDataExtension on UserResponseData {
···
}

```
## 解析单实体
```dart
String userData = """
    {
      "code": 200,
      "message": "success",
      "data":{
        "id": "12312312",
        "name": "loongwind",
        "age": 18
      }
    }
    """;

ApiResponseEntity<UserEntity> response = ApiResponseEntity.fromJson(jsonDecode(userData));
print(response.data?.name); // loongwind

```
## 解析Json数组
```dart
String userData = """
    {
      "code": 200,
      "message": "success",
      "data":[
        {
          "id": "12312312",
          "name": "loongwind",
          "age": 18
        },{
          "id": "333333",
          "name": "cmad",
          "age": 25
        }
      ]
    }
    """;

ApiResponseEntity<List<UserEntity>> response = ApiResponseEntity.fromJson(jsonDecode(userData));
print(response.data?.length); // 2
print(response.data?.first.name); // loongwind

```
## 解析基本数据类型
```dart
String jsonData = """
    {
      "code": 200,
      "message": "success",
      "data": 18
    }
    """;

ApiResponseEntity<int> response = ApiResponseEntity.fromJson(jsonDecode(jsonData));
print(response.data); // 18


String jsonData = """
    {
      "code": 200,
      "message": "success",
      "data": "123456"
    }
    """;

ApiResponseEntity<String> response = ApiResponseEntity.fromJson(jsonDecode(jsonData));
print(response.data); // 123456

String jsonData = """
    {
      "code": 200,
      "message": "success",
      "data": true
    }
    """;

ApiResponseEntity<bool> response = ApiResponseEntity.fromJson(jsonDecode(jsonData));
print(response.data); // true

```
