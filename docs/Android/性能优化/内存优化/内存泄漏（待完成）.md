1. 什么是内存泄漏
2. 与内存溢出(OOM)的区别
3. 内存泄漏的原因
4. 常见的内存泄漏场景与解决办法

# 什么是内存泄漏
没有用的对象资源仍然与GC-Root保持可达路径，导致系统无法进行回收。
没有用的对象的引用仍被其他对象所持有，而导致系统无法回收该对象，致使其一直占用着堆内存。
大量的内存泄漏会导致内存溢出（OOM）
本质原因：持有者的生命周期   >  被持有者的生命周期，导致后者的结束生命周期而销毁时，无法被正确回收。
# 与内存溢出的区别
据java的内存模型会出现内存溢出的内存有堆内存、 方法区内存、虚拟机栈内存、native方法区内存， 一般说的OOM基本都是针对堆内存；
内存溢出是指
堆内存溢出的根本原因：

1. app进程内存达到上限
2. 整个手机内存不足

对于APP进程内存达到上限导致内存溢出的主要情况：

1. 申请内存的速度超出gc释放内存的速度；比如频繁的创建大量对象或加载超大文件
2. 内存出现大量泄漏，gc无法回收泄漏的内存，导致可用内存越来越少
# 内存泄漏的原因

1. 非静态内部类默示持有外部类的引用，如非静态handler持有activity的引用
2. 接收器、监听器注册没取消造成的内存泄漏，如广播，eventsbus
3. Activity 的 Context 造成的泄漏，可以使用 ApplicationContext
4. 单例中的static成员间接或直接持有了activity的引用
5. 资源对象没关闭造成的内存泄漏（如： Cursor、File等）
6. 全局集合类强引用没清理造成的内存泄漏（特别是 static 修饰的集合）
# Thread导致内存泄漏
前备知识：

1. 垃圾回收器不会回收GC Roots以及那些被它们间接引用的对象
2. Java中非静态内部类默认会持有外部类的引用

因此在Activity中**创建内部类Thread开辟子线程**，当Thread中的任务没有执行完时，发生旋转屏幕导致Activity重建，那么Thread不会被销毁，而它默认持有的原来老的Activity的引用，因为原来的老Activity也不会被销毁，从而造成内存泄漏。
解决办法：

1. 将Thread类改为静态内部类

# Handler导致内存泄漏
原因:
1.Java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用
2.我们在Activity中使用非静态内部类初始化了一个Handler, 此Handler就会持有当前Activity的引用。
3.我们想要一个对象被回收，那么前提它不被任何其它对象持有引用， 所以当我们Activity页面关闭之后,存在引用关系： "未被处理 / 正处理的消息 -> Handler实例 -> 外部类", 如果在Handler消息队列 还有未处理的消息 / 正在处理消息时 导致Activity不会被回收，从而造成内存泄漏
解决方案: 
1.将Handler的子类设置成 静态内部类,使用WeakReference弱引用持有Activity实例
2.当外部类结束生命周期时，清空Handler内消息队列

[Android性能优化：关于 内存泄露 的知识都在这里了！](https://www.jianshu.com/p/97fb764f2669)
[Android内存泄漏分析及检测工具LeakCanary简介 - 掘金](https://juejin.cn/post/6974273866176659492#heading-10)
