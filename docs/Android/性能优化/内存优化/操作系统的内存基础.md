# 没有内存抽象
在早些的操作系统中，并没有引入内存抽象的概念。程序直接访问和操作的都是物理内存。比如当执行如下指令时：
```powershell
mov reg1,1000
```
这条指令会毫无想象力的将物理地址**1000**中的内容赋值给寄存器。不难想象，这种内存操作方式使得操作系统中存在多进程变得完全不可能，比如MS-DOS，你必须执行完一条指令后才能接着执行下一条。如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。
没有内存抽象对于内存的管理通常非常简单，除去操作系统所用的内存之外，全部给用户程序使用。或是在内存中多留一片区域给驱动程序使用
# 没有内存抽象存在的问题

1. 用户程序可以访问任意内存，容易破坏操作系统，造成崩溃
2. 同时运行多个程序特别困难，多进程的实现困难
# 什么是内存抽象
内存抽象，顾名思义就是对内存的抽象，从而衍生出一个概念叫做 地址空间，程序可以根据地址空间去找到对应的内存。一个进程的地址空间包含运行的程序的所有内存状态。不同的进程会有不同的地址空间，进程之间的程序和数据通过内存抽象，也就是地址空间而互不干扰。

- 动态重定位：通过重定位寄存器，把程序装入内存后，并不立即把程序的逻辑地址转换为物理地址，而是等到程序真正执行时才进行地址转换，动态重定位是交换技术的基础
- 交换技术：把内存中暂时不能运行的进程或者暂时不用的程序和数据换到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或者进程所需要的程序和数据换入内存，交换是分时运行多个程序的基础
# 地址空间的作用
引入地址空间主要解决了两个问题：

1. 避免直接把物理地址暴露给进程，用户不能再直接寻址到物理地址，有效避免了对操作系统的破坏
2. 同时运行多个程序困难，地址空间是以一个进程可用于寻址内存的一套地址的集合。每个进程都有自己的地址空间，并且这个地址空间独立于其他进程的地址空间。

# 虚拟内存
虚拟内存的出现是为了实现内存扩充，但并非是物理上扩大内存的容量，而是从逻辑上扩充内存的容量。给用户的感知就是可使用的内存容量好像比实际的内存容量大得多。
上面我们分析知道每个进程都有自己独立的逻辑地址空间，而内存的物理地址被分为大小相等的多个块，每个块都是一段连续的物理地址。举个例子，我们系统的内存只有12kb，但是现在我们要运行一个20kb的程序，其中一部分和物理内存上的块对应，一部分还没加载到内存中而与硬盘（外存）中对应。
![](http://starrylixu.oss-cn-beijing.aliyuncs.com/193db79632bb3593546aa9d7898d3db8.jpeg)
如图，在运行这个程序时，系统会利用程序的局部性原理，先加载需要运行的这一部分，当运行完后，请求其他部分时，发生**缺页中断，**这时会利用交换技术，把请求的部分放入内存运行，如果此时内存已满，还会利用**页面置换算法**去按照一定的规则换出旧的页面，给新的页面腾出空间。如此一个12kb内存的系统却可以运行20kb的程序，所以正是利用这样的机制，使得用户所感知到的内存比真实的内存容量大，这便是虚拟内存的意义。
## 页面置换算法
常见的页面置换算法有：
先进先出算法
LRU算法
等

