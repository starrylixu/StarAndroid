# 无状态组件
## 什么是无状态组件
无状态组件，其实并不是什么新的概念，我认为就是**静态界面**
如下我们实现一个静态界面，界面上展示的所有数据和按钮都不会因为事件触发或者时间推移而发生变化，所以是**无状态的**
```kotlin
@Composable
fun TodoScreen(
    items: List<TodoItem>
) {
    Column {
        LazyColumn(
            modifier = Modifier.weight(1f),
            contentPadding = PaddingValues(top = 8.dp)
        ) {
            items(items) {
                TodoRow(
                    todo = it,
                    Modifier.fillParentMaxWidth()//填充父容器的最大宽度
                )
            }

        }
        Button(
            onClick = { /*TODO*/ },
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth()//最大填充
        ) {
            Text(text = "add random item")
        }
    }
}

@Composable
fun TodoRow(
    todo: TodoItem,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween//子元素水平均匀分布
    ) {
        Text(text = todo.task)
        Icon(
            imageVector = todo.icon.imageVector,
            contentDescription = stringResource(id = todo.icon.contentDescription)
        )
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702101729675-b73a8c7a-5e27-47d4-869e-61b83f89f0ba.png#averageHue=%23f7f7f7&clientId=udd175de2-65f3-4&from=paste&height=728&id=u51bf36e2&originHeight=984&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30447&status=done&style=none&taskId=ucc421dca-939b-400e-b711-5aa770b6194&title=&width=410)
## 什么是状态
在App应用中的状态是**可以变化的任何值**。而状态组件就是向用户显示变化值的组件，例如：

- 展示网络连接状态的组件
- 显示博文相关评论的组件
- 用户点击时触发的动画效果
- ······

等等都可以看作是状态组件，它们承载着状态的变化（更新）。
状态的变化（更新）可能受时间的影响，也可能受事件而触发。而更多情况下状态的变化（更新）是受事件的驱动，最简单的理解就是**用户的点击事件**，它就是一种事件。事件会驱动状态变化（更新）
总而言之，这里有三个概念：

- 事件：通常由用户的操作生成，例如用户的点击事件
- 状态变化（更新）：事件会驱动状态的变化（更新）
- 显示状态：状态的变化最终以UI组件的形式展现给用户

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702124421078-7e29dc22-da44-4b18-af40-92631ef248e3.png#averageHue=%23fdfdfd&clientId=u88e91997-2726-4&from=paste&height=227&id=u1e51c5a0&originHeight=227&originWidth=401&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25388&status=done&style=none&taskId=uc7fecd53-ceb5-44b9-81cc-625128afedc&title=&width=401)
# 非结构化状态
阐述了什么是状态，那我们来看看在使用xml编写布局的时代下，我们是如何去管理状态的。
在使用xml布局的时代，我们使用的组件状态管理是**非结构化状态**，例如我们在输入框中输入，将输入框的内容状态变化反馈到TextView，实现如下：（使用了viewBInding获取控件）
```kotlin
class UnStructureActivity : Activity() {

    private val binding by lazy {
        ActivityUnStructureBinding.inflate(layoutInflater)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(binding.root)
        binding.editTextText.doAfterTextChanged { text ->
            updateHello(text.toString())
        }
    }

    private fun updateHello(string: String) {
        binding.textView.text = "$string"
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702103449110-8ac8fb42-7c36-4519-b072-5603bb81f330.png#averageHue=%23ededed&clientId=udd175de2-65f3-4&from=paste&height=376&id=u116e7436&originHeight=376&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9598&status=done&style=none&taskId=u1b0d5c82-a788-4471-8880-a018d041138&title=&width=554)
## 存在的问题
上面的例子中，**对UI的操作**和**对UI上事件的处理**是交织在一起，耦合严重，这意味着我们要在同一段代码中管理者UI的变化和状态的变化。这会带来很多问题：

1. 不便于自动化测试
2. 部分状态更新，当屏幕有更多事件时，很容易忘记更新部分状态以响应事件。
3. 部分UI更新，由于我们在每次状态更改后手动更新UI，因此有时很容易忘记这一点。
4. 代码复杂性，在这种模式下编码时很难提取一些逻辑。代码变得难以阅读和理解。
# 单向数据流
针对非结构化状态存在的问题，引入了**ViewModel**和**LiveData**。
我们将状态从Activity中移到了ViewModel，在ViewModel中，状态由LiveData表示。
LiveData是一种可观察状态容器，这意味着它可让任何对象观察状态的变化。然后，我们
在界面中使用`observe`方法，以便在状态变化时更新界面。（一种观察者模式）
通ViewModel和LiveData可以实现单向数据流动：
因事件而携带的数据从Activity单向流动至ViewModel中，而状态又从ViewModel中流回Activity中。

- 事件：当文本输入更改时由UI调用`onNameChanged`
- 状态变化（更新）：由ViewModel中的`onNameChanged`处理，更新状态`name`
- 显示状态：name的观察者被调用，通知TextView状态变化
```kotlin
class SingleDataFlowActivity : AppCompatActivity() {

    private val binding by lazy {
        ActivityUnStructureBinding.inflate(layoutInflater)
    }
    private val viewModel: HelloViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(binding.root)

        binding.editTextText.doAfterTextChanged { text ->
            viewModel.onNameChanged(text.toString())
        }
        viewModel.name.observe(this) { name ->
            binding.textView.text = name
        }
    }

}


class HelloViewModel : ViewModel() {

    //私有的状态，可读可写
    private val _name = MutableLiveData("")
    //这个属性只读的，外部只需要监听name的变化
    val name: LiveData<String> = _name
    //状态的改变只交给ViewModel
    fun onNameChanged(newName: String) {
        _name.value = newName
    }
}
```
> 注意：关于为什么ViewModel可以用来管理状态，以上的name属性是只读的，Activity中只能监听name的变化，而不能在修改它。它只能被`onNameChanged`方法修改。

总而言之：事件从Activity中产生，携带数据流动到ViewModel中，ViewModel负责管理状态，Activity中观察状态的变化，更新UI。**事件向上流动，状态向下流动**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702104810928-9b463cad-517c-46ba-bde3-3152fc879505.png#averageHue=%23dbd4cd&clientId=u88e91997-2726-4&from=paste&height=492&id=u0c1db183&originHeight=492&originWidth=1091&originalType=binary&ratio=1&rotation=0&showTitle=false&size=158889&status=done&style=none&taskId=uf6203d42-45fe-438e-be55-3834298d3bd&title=&width=1091)
## 单项数据流的优势
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702105059237-6317a8eb-14a2-4bef-9422-7c61df91403e.png#averageHue=%23dfd6ce&clientId=u88e91997-2726-4&from=paste&height=318&id=u32aadf6b&originHeight=318&originWidth=1064&originalType=binary&ratio=1&rotation=0&showTitle=false&size=201410&status=done&style=none&taskId=u7126f0e7-6131-4ddb-acee-4b9002f6f2c&title=&width=1064)
单向数据流是一种**状态向下流动而事件向上流动**的设计，它的优势有：

- 提高可测试性，通过将状态与显示它的ul分离，可以更轻松地测试viewmodel和activity.
- 对状态封装，因为状态只能在一个地方（ViewModel)更新，随着UI的代码增加，不太可能引入
部分状态更新错误。
- 保证UI一致性，所有状态更新都通过使用可观察状态持有者立即反映在UI中。
# Compose的状态管理
## 状态组件
现在我们在之前的Compose静态界面上引入**单向数据流**来管理状态，实现单击按钮添加一个item，而点击item实现删除。
首先我们需要一个随机生成item的函数
```kotlin
fun generateRandomTodoItem(): TodoItem {
    val message = listOf(
        "learn compose",
        "learn state",
        "learn compose state",
        "learn LiveData",
        "learn ViewModel",
        "learn Android"
    ).random()
    val icon = TodoIcon.values().random()
    return TodoItem(message, icon)
}
```
提供给button调用实现单击按钮，添加一条item
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702106852491-6fc016e6-36ca-4342-bb78-b9dc2d314848.png#averageHue=%231f2125&clientId=u88e91997-2726-4&from=paste&height=226&id=u6daba2b4&originHeight=226&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20247&status=done&style=none&taskId=u10cdbb61-db2f-44ce-9d45-9b8a34d10a5&title=&width=400)
而增加一个item和删除一个item都是一次事件，它们会触发状态的变化，这里的状态就是items，因此我们使用ViewModel去管理这组状态，并且提供对应的增加item和删除item的方法，提供给外部去调用，实现对状态的更改。
以下是`TodoViewModel`的实现：
```kotlin
class TodoViewModel : ViewModel() {
    private var _todoItems = MutableLiveData(listOf<TodoItem>())
    val todoItems: LiveData<List<TodoItem>> = _todoItems
    fun addItem(item: TodoItem) {
        //注意这里需要改变集合，才会算作状态更新
        _todoItems.value = _todoItems.value!! + listOf(item)
        //如果这样，仅仅是改变了集合中的内容，集合本身并没有改变
//        _todoItems.value[_todoItems.value!!.size+1]=item
    }

    fun removeItem(item: TodoItem) {
        //通过toMutableList()转成一个新的集合
        _todoItems.value = _todoItems.value!!.toMutableList().also {
            it.remove(item)
        }
    }
}
```
以下是TodoScreen的全部代码，可以看到它只负责传递事件和数据。具体的对状态的管理并不需要关心。
```kotlin
@Composable
fun TodoScreen(
    items: List<TodoItem>,
    onAddItem: (TodoItem) -> Unit,
    onRemoveItem: (TodoItem) -> Unit
) {
    Column {
        LazyColumn(
            modifier = Modifier.weight(1f),
            contentPadding = PaddingValues(top = 8.dp)
        ) {
            items(items) { it ->
                TodoRow(
                    todo = it,
                    modifier = Modifier.fillParentMaxWidth(),//填充父容器的最大宽度
                    onItemClicked = { onRemoveItem(it) }
                )
            }

        }
        Button(
            onClick = {
                onAddItem(generateRandomTodoItem())
            },
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth()//最大填充
        ) {
            Text(text = "add random item")
        }
    }
}

@Composable
fun TodoRow(
    todo: TodoItem,
    onItemClicked: (TodoItem) -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .clickable { onItemClicked(todo) }
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween//子元素水平均匀分布
    ) {
        Text(text = todo.task)
        Icon(
            imageVector = todo.icon.imageVector,
            contentDescription = stringResource(id = todo.icon.contentDescription)
        )
    }
}
```
在调用者TodoActivity中，我们使用**属性委托，**只要集合List发生变化，状态会自动去更新，这里的状态就是`items`，也就是数据项更新后，LazyColumn中的条目就会相应的添加，减少。
```kotlin
class TodoActivity : ComponentActivity() {

    private val viewModel: TodoViewModel by viewModels()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Compose_studyTheme {
                TodoActivityScreen()
            }
        }
    }

    @Composable
    private fun TodoActivityScreen() {
//      属性委托，只要集合List发生变化，状态会自动去更新
        val items: List<TodoItem> by viewModel.todoItems.observeAsState(listOf())
        TodoScreen(items = items,
            onAddItem = { viewModel.addItem(it) },
            onRemoveItem = { viewModel.removeItem(it) })
    }
}
```

- 事件：当用户请求添加或删除项时，TodoScreen 会调用 `onAddItem` 或 `onRemoveltem`
- 状态更新：TodoScreen 的调用方可以通过更新状态来响应这些事件
- 显示状态：状态更新后，系统将使用新的items再次调用TodoScreen，而且后者可以在界面上显示它们。

如此**TodoScreen**与**其上的状态（items) **是完全解耦的。
若要实现布局和状态的分离，我们一般需要引入两个参数：value对应着状态，而onValueChange对应着更新状态的方法。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702106610207-c6c20483-a4c2-4b5f-8d43-3df989ecafe7.png#averageHue=%23fbfaf9&clientId=u88e91997-2726-4&from=paste&height=244&id=u25629069&originHeight=244&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128771&status=done&style=none&taskId=ud2e20989-e2fc-4d39-828a-94adc4d1389&title=&width=1106)
## 重组
我们的状态发生更新时可组合函数会发生重组，对应的组件树会使用新的数据重新初始化，而之前保存的临时数据会丢失。例如之前我们的items发生改变，LazyColumn会重组，而Button不会发生重组。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702107703516-eccfc627-8efa-4d0b-b9a1-f60e7ab9d9ba.png#averageHue=%23fdfdfd&clientId=u88e91997-2726-4&from=paste&height=646&id=u5ae32b1b&originHeight=646&originWidth=1346&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199301&status=done&style=none&taskId=u919cbc3e-a28a-491f-b1a9-5ec8ce12692&title=&width=1346)
例如我们实现一个效果，给每一个Icon初始化一个随机的透明度，我们如果使用如下实现会出现一个问题，每一添加一个Item，之前的Item的Icon的透明度都会随机变化，而并没有保存一开始的透明度。
这是因为LazyColumn中的值发生改变，所以LazyColumn函数会被重新调用，因此item上的随机透明度也会每次都被调用而导致每次都不一样。这个案例中Button是不会被重组，因为其中的值没有发生变化
```kotlin
@Composable
fun TodoRow(
    todo: TodoItem,
    onItemClicked: (TodoItem) -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .clickable { onItemClicked(todo) }
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween//子元素水平均匀分布
    ) {
        Text(text = todo.task)
        Icon(
            imageVector = todo.icon.imageVector,
            //隐式传参
            tint = LocalContentColor.current.copy(alpha = Random.nextFloat().coerceIn(0.3f, 0.9f)),
            contentDescription = stringResource(id = todo.icon.contentDescription)
        )
    }
}
```
那么如何解决这个问题呢？很简单我们如果能提供一个内存区域保存这个Icon的透明度，每次LazyColumn发生重组时，我们使用这块内存区域的透明度的值。
remember可以实现这个需求，可以将它看作是为函数提供单个对象的存储空间。这样我们就让可组合项也有状态。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702107918308-5b14e2b4-2696-4117-9bfc-57d64785123c.png#averageHue=%23e4dcc8&clientId=u88e91997-2726-4&from=paste&height=634&id=u289dc3d7&originHeight=634&originWidth=1335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=201008&status=done&style=none&taskId=ufda106b1-881c-4b4f-b199-ac9883ec621&title=&width=1335)
```kotlin
@Composable
fun TodoRow(
    todo: TodoItem,
    onItemClicked: (TodoItem) -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .clickable { onItemClicked(todo) }
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween//子元素水平均匀分布
    ) {
        Text(text = todo.task)

        val iconAlpha: Float = remember(todo.id) { Random.nextFloat().coerceIn(0.3f, 0.9f) }
        Icon(
            imageVector = todo.icon.imageVector,
            //隐式传参
            tint = LocalContentColor.current.copy(alpha = iconAlpha),
            contentDescription = stringResource(id = todo.icon.contentDescription)
        )
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702108150161-1e8cfeaa-4301-4d25-a07c-5d58c2579aef.png#averageHue=%23e2ddd5&clientId=u88e91997-2726-4&from=paste&height=452&id=u5fe7ae28&originHeight=452&originWidth=1366&originalType=binary&ratio=1&rotation=0&showTitle=false&size=315849&status=done&style=none&taskId=uc59312f8-93da-45a2-8689-04ee450e264&title=&width=1366)

## MutableStateOf
下面我们要实现一种效果，在edit中有内容时，按钮可点击；edit中没有内容时，按钮不可点击。
使用之前的单向数据流，我们可以使用MutableLiveData来管理状态，这里的状态就是edit上的内容，同时也需要一个方法来更新状态
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702191364017-389bc57a-fe67-4bc0-b127-47d3a3d6ef62.png#averageHue=%23cfc7df&clientId=u8671534b-8515-4&from=paste&height=133&id=udd159e82&originHeight=99&originWidth=294&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=3536&status=done&style=none&taskId=ub3165765-e1ea-4749-94db-c112317ecab&title=&width=396)
所以我们这样定义输入框组件
```kotlin
//输入框
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TodoInputText(
    text: String, 
    onTextChange: (String) -> Unit, 
    modifier: Modifier = Modifier
) {

    TextField(
        value = text, onValueChange = onTextChange, maxLines = 1, modifier = modifier
    )
}
```
而按钮则需要观察状态的变化，来改变自身的UI状态，即是否可以点击
因此按钮组件的定义如下
```kotlin
//按钮
@Composable
fun TodoEditButton(
    onClick: () -> Unit,
    text: String,
    modifier: Modifier = Modifier,
    enable: Boolean = true
) {

    TextButton(
        onClick = onClick,
        shape = CircleShape,
        colors = ButtonDefaults.buttonColors(),
        modifier = modifier,
        enabled = enable
    ) {
        Text(text = text)
    }
}

```
最后组合两个组件，构成了我们一开始看到的图片上展示的UI效果，
可以看到在TodoEditButton组件中`enable` 被赋值为 `text.isNotBlank()`，所以实现对EditView状态的监听。
```kotlin
@Composable
fun TodoItemInput(
    onItemComplete: (TodoItem) -> Unit
) {

    //关键点在这里，text和setText是mutableStateOf类型
    val (text, setText) = remember {
        mutableStateOf("")
    }
    Row(
        Modifier
            .padding(horizontal = 16.dp)
            .padding(top = 16.dp)
    ) {
        TodoInputText(
            text = text, onTextChange = setText, modifier = Modifier
                .weight(1f)
                .padding(end = 8.dp)
        )

        TodoEditButton(
            onClick = {
                onItemComplete(TodoItem(text))
                setText("")
            },
            text = "add",
            modifier = Modifier.align(Alignment.CenterVertically),
            enable = text.isNotBlank()
        )
    }
}
```
看上去很神奇，之前的例子中我们要实现对状态的更新。
EditView上的text发生了改变，会调用setText，当输入框中的内容发生变化时会自动调用setText，而setText会去改变`MutableState`中的value值，因此使用到了 这个`MutableState`对象的可组合函数都会发生重组，这也是为什么我们在输入框中输入内容，按钮的状态会跟随变化。
`remember`给自己添加内存，然后在内存中存储一个由`MutableStateOf`创建的 `MutableState<String>`，它是 compose 的内置类型，提供了一个可观察的状态持有者。对 value 的任何更改都将自动重新组合读取此状态的任何可组合函数。
需要注意的时创建State<T>对象时，必须执行`remember`操作，否则每次重组时之前保存的状态都会被初始化，还原成为初始值。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702193563344-2b6899c2-97d7-4cf6-a72b-7ad690a1cd00.png#averageHue=%23f7f7f1&clientId=u8671534b-8515-4&from=paste&height=410&id=u19f878f3&originHeight=410&originWidth=1177&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=66407&status=done&style=none&taskId=u37f79536-cbd7-4229-b896-c92d07ccae9&title=&width=1177)
可见`MutableState<T>`类似于`MutableLiveData<T>`，但是`MutableState<T>`与Compose集成了，它更新时会通知Compose。不同于`MutableLiveData<T>`，我们还需要调用`observeAsState`去监听状态。
## MutableStateOf实践
实现输入框中有文字，显示下方图标，输入框中无文字隐藏下方图标
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702198430364-1f6cb228-08c8-468d-8c13-8425324e7984.png#averageHue=%23eae6ef&clientId=u8671534b-8515-4&from=paste&height=174&id=ua0721f9f&originHeight=174&originWidth=446&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4843&status=done&style=none&taskId=uacd0705d-2714-48af-ae0a-06d650f66fa&title=&width=446)
```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TodoInputText(
    text: String, onTextChange: (String) -> Unit, modifier: Modifier = Modifier
) {

    TextField(
        value = text, onValueChange = onTextChange, maxLines = 1, modifier = modifier
    )
}

//增加一排图标，根据文本框是否有内容，自动收起和弹出
@Composable
fun AnimatedIconRow(
    icon: TodoIcon,
    onIconChange: (TodoIcon) -> Unit,
    modifier: Modifier = Modifier,
    visible: Boolean = true,
) {
    //动画也要结合remember
    val enter = remember {
        fadeIn(animationSpec = TweenSpec(300, easing = FastOutLinearInEasing))
    }
    val exit = remember {
        fadeOut(animationSpec = TweenSpec(100, easing = FastOutSlowInEasing))
    }

    Box(modifier = modifier.defaultMinSize(minHeight = 16.dp)) {
        AnimatedVisibility(
            visible = visible,
            enter = enter,
            exit = exit
        ) {
            IconRow(icon = icon, onIconChange = onIconChange)
        }
    }

}

//图标组件
@Composable
fun IconRow(
    icon: TodoIcon,
    onIconChange: (TodoIcon) -> Unit,
    modifier: Modifier = Modifier
) {
    Row(modifier) {
        for (todoIcon in TodoIcon.values()) {
            SelectableIconButton(
                icon = todoIcon.imageVector,
                iconContentDescription = todoIcon.contentDescription,
                onIconSelected = { onIconChange(todoIcon) },
                isSelected = (todoIcon == icon)
            )
        }
    }
}

//单个图标的组件
@Composable
fun SelectableIconButton(
    icon: ImageVector,
    iconContentDescription: Int,
    onIconSelected: () -> Unit,
    isSelected: Boolean,//是否选中
    modifier: Modifier = Modifier
) {

    val tint = if (isSelected) {
        MaterialTheme.colorScheme.primary
    } else {
        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
    }
    TextButton(
        onClick = {
            onIconSelected()
        },
        shape = CircleShape,
        modifier = modifier
    ) {
        Column {
            Icon(
                imageVector = icon,
                tint = tint,
                contentDescription = stringResource(id = iconContentDescription)
            )
            if (isSelected) {
                Box(
                    modifier = Modifier
                        .padding(top = 3.dp)
                        .width(icon.defaultWidth)
                        .height(1.dp)
                        .background(tint)
                )
            } else {
                Spacer(modifier = Modifier.height(4.dp))
            }
        }
    }
}


//按钮
@Composable
fun TodoEditButton(
    onClick: () -> Unit,
    text: String,
    modifier: Modifier = Modifier,
    enable: Boolean = true
) {

    TextButton(
        onClick = onClick,
        shape = CircleShape,
        colors = ButtonDefaults.buttonColors(),
        modifier = modifier,
        enabled = enable
    ) {
        Text(text = text)
    }
}

@Composable
fun TodoItemInput(
    onItemComplete: (TodoItem) -> Unit
) {

    //关键点在这里，text和setText是mutableStateOf类型
    val (text, setText) = remember {
        mutableStateOf("")
    }
    val (icon, setIcon) = remember {
        mutableStateOf(TodoIcon.Default)
    }
    //IconRow是否可见取决于文本框是否有文本
    val iconsVisible = text.isNotBlank()

    Column {
        Row(
            Modifier
                .padding(horizontal = 16.dp)
                .padding(top = 16.dp)
        ) {
            TodoInputText(
                text = text,
                onTextChange = setText,
                modifier = Modifier
                    .weight(1f)
                    .padding(end = 8.dp)
            )

            TodoEditButton(
                onClick = {
                    onItemComplete(TodoItem(text))
                    setText("")
                },
                text = "add",
                modifier = Modifier.align(Alignment.CenterVertically),
                enable = text.isNotBlank()
            )
        }
        AnimatedIconRow(
            icon = icon,
            visible=iconsVisible,
            onIconChange = setIcon,
            modifier = Modifier.padding(top = 8.dp)
        )
    }

}
```
## 添加软键盘
配置软件盘，点击软键盘实现提交内容
给输入框组件配置**软键盘的样式**以及软键盘点击done之后的逻辑，隐藏软键盘
```kotlin
//输入框
@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)
@Composable
fun TodoInputText(
    text: String,
    onTextChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    onItemAction: () -> Unit = {}
) {

    val keyboardController = LocalSoftwareKeyboardController.current
    TextField(
        value = text, onValueChange = onTextChange, maxLines = 1, modifier = modifier,
        //配置软键盘
        keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Done),
        keyboardActions = KeyboardActions(onDone = {
            onItemAction()
            //点击软键盘后，隐藏软键盘
            keyboardController?.hide()
        }),
        singleLine = true
    )
}
```
在调用输入框组件的位置，传入onItemAction的值即可。
```kotlin
@Composable
fun TodoItemInput(
    onItemComplete: (TodoItem) -> Unit
) {
    ···

    //点击add按钮后提交要做的事
    val submit = {
        onItemComplete(TodoItem(text))
        setIcon(TodoIcon.Default)//icon图标选中默认的
        setText("")//view上的内容设置为空
    }
    Column {
        Row(
            Modifier
                .padding(horizontal = 16.dp)
                .padding(top = 16.dp)
        ) {
            TodoInputText(
                text = text,
                onTextChange = setText,
                modifier = Modifier
                    .weight(1f)
                    .padding(end = 8.dp),
                onItemAction = { submit() }
            )

            TodoEditButton(
                onClick = {
                    submit()
                },
                text = "add",
                modifier = Modifier.align(Alignment.CenterVertically),
                enable = text.isNotBlank()
            )
        }
       ···
    }

}
```
## 添加背景阴影
首先添加一个背景阴影
```kotlin
@Composable
fun TodoItemInputBackground(
    elevate: Boolean,
    modifier: Modifier = Modifier,
    content: @Composable RowScope.() -> Unit
) {
    //帧动画的形式展现Surface底部的阴影
    val animatedElevation by animateDpAsState(
        if (elevate) 1.dp else 0.dp,
        TweenSpec(100), label = "帧动画的形式展现Surface底部的阴影"
    )
    Surface(
        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
        shadowElevation = animatedElevation,
        shape = RectangleShape
    ) {

        Row(
            modifier = modifier.animateContentSize(TweenSpec(300)),
            content = content
        )
    }
}
```
其次因为我们的**TodoItemInput**多次被使用了，并且其中的状态有很多，所以可以进行一次状态提升。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702209693702-9f12904e-d13e-49ed-a296-7fa1da3f1b68.png#averageHue=%231f2125&clientId=u8671534b-8515-4&from=paste&height=466&id=u33e2aa18&originHeight=466&originWidth=502&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=44750&status=done&style=none&taskId=ueb710f7a-d8fd-437a-a8e0-6c62f4d73ae&title=&width=502)
对**TodoItemInput**再次封装，提高**TodoItemInput的**可重用性。如下状态提升至TodoItemEntryInput中，**TodoItemInput**负责接收状态值
```kotlin
@Composable
fun TodoItemEntryInput(
    onItemComplete: (TodoItem) -> Unit
) {

    //关键点在这里，text和setText是mutableStateOf类型
    val (text, setText) = remember {
        mutableStateOf("")
    }
    val (icon, setIcon) = remember {
        mutableStateOf(TodoIcon.Default)
    }
    //IconRow是否可见取决于文本框是否有文本
    val iconsVisible = text.isNotBlank()

    //点击add按钮后提交要做的事
    val submit = {
        onItemComplete(TodoItem(text,icon))
        setIcon(TodoIcon.Default)//icon图标选中默认的
        setText("")//view上的内容设置为空
    }

    TodoItemInput(
        text = text,
        onTextChanged = setText,
        icon = icon,
        onIconChanged = setIcon,
        submit = submit,
        iconsVisible = iconsVisible
    )
}
```
在使用的位置，使用TodoItemInputBackground组件去包裹TodoItemEntryInput输入框即可。
```kotlin
@Composable
fun TodoScreen(
    items: List<TodoItem>,
    onAddItem: (TodoItem) -> Unit,
    onRemoveItem: (TodoItem) -> Unit
) {
    Column {

        TodoItemInputBackground(elevate = true) {
            TodoItemEntryInput(onItemComplete = onAddItem)
        }
        LazyColumn(
            modifier = Modifier.weight(1f),
            contentPadding = PaddingValues(top = 8.dp)
        ) {
            items(items) { it ->
                TodoRow(
                    todo = it,
                    modifier = Modifier.fillParentMaxWidth(),//填充父容器的最大宽度
                    onItemClicked = { onRemoveItem(it) }
                )
            }

        }
        Button(
            onClick = {
                onAddItem(generateRandomTodoItem())
            },
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth()//最大填充
        ) {
            Text(text = "add random item")
        }
    }
}
```
最终在首屏Activity中，使用TodoScreen组件
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702210925182-53bc59bf-9a80-4e18-ba43-ff687f214559.png#averageHue=%232f3034&clientId=u8671534b-8515-4&from=paste&height=1032&id=u00c04725&originHeight=1032&originWidth=1920&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=300965&status=done&style=none&taskId=u56648f20-c763-4611-911c-d2959deed30&title=&width=1920)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32682386/1702210766146-e587497e-041d-47a4-b2f4-7123e071a6e1.png#averageHue=%23d1d4cd&clientId=u8671534b-8515-4&from=paste&height=812&id=uf702d002&originHeight=812&originWidth=365&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=110139&status=done&style=none&taskId=uc0ca5399-5e8b-4851-a944-e5e725456f9&title=&width=365)
## 编辑模式
添加编辑模式，就是再现有的基础上，我们点击具体的某一个条目，它会展开进入可编辑状态。
这时我们对`TodoItemInput`的状态提升就能体现复用性了，在正常的添加模式时我们使用`TodoItemEntryInput`组件，将需要的状态传入`TodoItemInput`
```kotlin

@Composable
fun TodoItemEntryInput(
    onItemComplete: (TodoItem) -> Unit
) {

    //关键点在这里，text和setText是mutableStateOf类型
    val (text, setText) = remember {
        mutableStateOf("")
    }
    val (icon, setIcon) = remember {
        mutableStateOf(TodoIcon.Default)
    }
    //IconRow是否可见取决于文本框是否有文本
    val iconsVisible = text.isNotBlank()

    //点击add按钮后提交要做的事
    val submit = {
        onItemComplete(TodoItem(text, icon))
        setIcon(TodoIcon.Default)//icon图标选中默认的
        setText("")//view上的内容设置为空
    }

    TodoItemInput(
        text = text,
        onTextChanged = setText,
        icon = icon,
        onIconChanged = setIcon,
        submit = submit,
        iconsVisible = iconsVisible
    ) {
        TodoEditButton(
            onClick = {
                submit()
            },
            text = "add",
            enable = text.isNotBlank()
        )
    }
}

```
而编辑状态下的组件复用`TodoItemInput`，传入这个`TodoItemInput`需要的状态。
注意这里我们对`TodoItemInput`里的按钮组件也做了状态提升，让我们可以传入任意的组件进去
```kotlin
@Composable
fun TodoItemInlineEditor(
    item: TodoItem,//选中的条目
    onEditItemChange: (TodoItem) -> Unit,//编辑条目时的回调
    onEditDone: () -> Unit,//编辑完成时的回调
    onRemoveItem: () -> Unit//删除条目时的回调
) {


    TodoItemInput(
        text = item.task,
        onTextChanged = { onEditItemChange(item.copy(task = it)) },
        icon = item.icon,
        onIconChanged = { onEditItemChange(item.copy(icon = it)) },
        submit = { onEditDone },
        iconsVisible = true,
        buttonSlot = {
            //保存和删除两个图标
            Row {
                val shrinkButtons = Modifier.widthIn(20.dp)
                TextButton(onClick = onEditDone, modifier = shrinkButtons) {
                    Text(
                        text = "\uD83D\uDCBE",
                        textAlign = TextAlign.End
                    )
                }

                TextButton(onClick = onRemoveItem, modifier = shrinkButtons) {
                    Text(
                        text = "❌",
                        textAlign = TextAlign.End
                    )
                }
            }
        }
    )
}
```
来到`TodoScreen`组件中，它根据用户此时是否点击了编辑，来区分进入添加模式和编辑模式。
```kotlin
@Composable
fun TodoScreen(
    items: List<TodoItem>,
    onAddItem: (TodoItem) -> Unit,
    currentEditing: TodoItem?,
    onRemoveItem: (TodoItem) -> Unit,
    onStartEdit: (TodoItem) -> Unit,
    onEditItemChange: (TodoItem) -> Unit,
    onEditDone: () -> Unit
) {
    Column {

        //当currentEditing为空时，显示添加输入框
        //否则进入编辑状态，最顶部会显示“Editing Item”文本
        val enableTopSelection = (currentEditing == null)


        TodoItemInputBackground(elevate = true) {
            if (enableTopSelection) {
                TodoItemEntryInput(onItemComplete = onAddItem)
            } else {
                Text(
                    text = "Editing Item",
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center,
                    modifier = Modifier
                        .align(Alignment.CenterVertically)
                        .padding(16.dp)
                        .fillMaxWidth()
                )
            }
        }
        LazyColumn(
            modifier = Modifier.weight(1f),
            contentPadding = PaddingValues(top = 8.dp)
        ) {
            items(items) { todo ->
                if (currentEditing?.id == todo.id) {
                    TodoItemInlineEditor(
                        item = currentEditing,
                        onEditItemChange = onEditItemChange,
                        onEditDone = onEditDone,
                        onRemoveItem = {onRemoveItem(todo)})
                } else {
                    TodoRow(
                        todo = todo,
                        modifier = Modifier.fillParentMaxWidth(),//填充父容器的最大宽度
                        onItemClicked = { onStartEdit(todo) }
                    )
                }

            }

        }
        Button(
            onClick = {
                onAddItem(generateRandomTodoItem())
            },
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth()//最大填充
        ) {
            Text(text = "add random item")
        }
    }
}
```
最后来到使用整个组件的Activity中，可以看到此时TodoScreen有很多的状态
```kotlin
class TodoActivity : ComponentActivity() {

    private val viewModel: TodoViewModel by viewModels()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Compose_studyTheme {
                TodoActivityScreen()
            }
        }
    }

    @Composable
    private fun TodoActivityScreen() {
        TodoScreen(
            items = viewModel.todoItems,
            currentEditing = viewModel.currentEditItem,//正在编辑的条目
            onAddItem = viewModel::addItem,//增加
            onRemoveItem = viewModel::removeItem,//删除
            onStartEdit = viewModel::onEditItemSelected,//开始编辑
            onEditItemChange = viewModel::onEditItemChange,//正在编辑
            onEditDone = viewModel::onEditDone//编辑完成
        )
    }
}
```
需要管理这么多状态，我们也可以把状态封装再viewModel中，这和之前提到一样
不过这一次我们不再使用LiveData，而是使用Compose中支持的mutableStateListOf。
```kotlin
/**
 * 状态容器
 */
class TodoViewModel : ViewModel() {


    //设置TodoItem集合只读，注意这里没有再使用remember，因为viewModel可以保存状态
    //只要进程没有杀死，都会保存在内存中
    var todoItems = mutableStateListOf<TodoItem>()
        private set

    //当前正在编辑的todoItem的索引
    private var currentEditPosition by mutableIntStateOf(-1)

    //当前正在编辑的todoItem对象
    val currentEditItem: TodoItem?
        get() = todoItems.getOrNull(currentEditPosition)//如果currentEditPosition为-1，则返回一个空

    //添加
    fun addItem(item: TodoItem) {
        todoItems.add(item)
    }

    //删除
    fun removeItem(item: TodoItem) {
        todoItems.remove(item)
        onEditDone()
    }

    fun onEditDone() {
        currentEditPosition = -1
    }

    //当TodoItem列表中的条目被选中时，传入该对象，获取它在列表中的索引
    fun onEditItemSelected(item: TodoItem) {
        currentEditPosition = todoItems.indexOf(item)
    }

    //TodoItem编辑完成，重新给集合中的TodoItem赋值
    //id属性值不能修改，进行校验
    fun onEditItemChange(item: TodoItem) {
        val currentItem = requireNotNull(currentEditItem)
        require(currentItem.id == item.id) {
            "you can only change an item with the same id as currentEditItem"
        }
        todoItems[currentEditPosition] = item
    }
}
```
如此大功造成，通过这个按钮，我们循序渐进的了解了什么时状态，以及Compose对于管理状态组件得天独厚的优势与支持。这样我们能更大程度更灵活的复用组件，搭配ViewModel和mutableStateListOf，我们可以实现状态的管理。
